{"posts":[{"title":"【Git】git stash 相关记录","content":"alias 相关配置 ➜ gridea git:(master) ag gst gst='git status' gsta='git stash push' gstaa='git stash apply' gstall='git stash --all' gstc='git stash clear' gstd='git stash drop' gstl='git stash list' gstp='git stash pop' gsts='git stash save' gstss='git stash show --text' gstu='git stash --include-untracked' 以上是我的 git stash 相关的 alias 配置，包括 zsh 自带的配置以及自己在.bashrc 里面的自定义配置，如何配置这里就不展开讲了。 下面介绍一下我们常用的几条 stash 命令： (这里就直接用设置的快捷命令了) gstc 清空栈 gsta 将本地修改的代码推到栈内 ➜ gridea git:(master) ✗ ga . ➜ gridea git:(master) ✗ gsta Saved working directory and index state WIP on master: abe8de5 docs: update changelog gstl 查看栈 gsts 在 gsta 的基础上可以自定义备注 ➜ gridea git:(master) ✗ ga . ➜ gridea git:(master) ✗ gsts &quot;save 2222&quot; Saved working directory and index state On master: save 2222 相比第一次提交，加了备注的提交更清晰 同时根据序列号也可以看出，stash 符合 先进先出 的规则 查看某一次提交 如上图，目前栈内有三次提交记录。 gstss 默认查看最近的一次提交，相当于gstss stash@{0} 如果想针对查看特定的提交，如 &quot;save 2222&quot; 的提交记录，需要在后面加上特定提交的序号gstss stash@{1} ，下面讲到的其他操作也是同理。 找到某次的提交记录后，需要将提交记录拷贝到本地，有两种方法： gstaa 从栈中拷贝出提交到本地（栈中的记录仍保留） gstp 从栈中推出某次提交（推出后，栈中不再留有这次提交记录） 由 gstp 操作也可以看出，gstd 其实就是删除栈内特定的提交记录，如删除 stash@{1} 的记录 ➜ gridea git:(master) ✗ gstd stash@{1} Dropped stash@{1} (95485801bdcb11f2e81c916529b447ff4f1da02f) 总结 gst='git status' gsta='git stash push' //保存（不加说明） gsts='git stash save' //保存（加说明） gstaa='git stash apply' //复制某次提交到本地 gstp='git stash pop' //复制某次提交到本地，并删除栈内记录 gstall='git stash --all' gstc='git stash clear' //清空栈 gstd='git stash drop' //删除栈内某次提交记录 gstl='git stash list' //查看栈内提交列表 gstss='git stash show --text' //查看栈内某次提交记录 gstu='git stash --include-untracked' ","link":"https://JoelynZhou.github.io/post/git-git-stash-xiang-guan-ji-lu/"},{"title":"浏览器新开 tab 遇到的问题记录","content":"页面跳转的两种方法 Onclick 跳转 window.location.href=&quot;URL&quot;;//覆盖当前页 window.open(&quot;URL&quot;,&quot;_blank&quot;);//新窗口打开 window.open(&quot;URL&quot;,&quot;_self&quot;);//覆盖当前页 若一直通过新窗口打开，会打开很多相同的页面，根据当前页面是否打开决定是新开标签页还是跳转： window.open(&quot;URL&quot;,&quot;PageTitle&quot;); 上述代码存在问题： Firefox 下存在兼容性问题，对已打开的页面不能成功跳转！！！ 解决方案： const winRef=window.open(&quot;URL&quot;,&quot;PageTitle&quot;); winRef.focus(); // 兼容 Firefox 无法跳转问题 a 标签跳转 &lt;!--新窗口打开--&gt; &lt;a href=&quot;URL&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt; &lt;!--覆盖当前页--&gt; &lt;a href=&quot;URL&quot; target=&quot;_self&quot;&gt;&lt;/a&gt; a 标签下实现页面不重复的打开： &lt;!--覆盖当前页--&gt; &lt;a href=&quot;URL&quot; target=&quot;PageTitle&quot;&gt;&lt;/a&gt; 上述方案无需考虑兼容性。 注意：PageTitle 为当前页面的 title，URL为当前页面的链接。 DEMO 目录结构： a.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Page1&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;b.html&quot; target=&quot;Page2&quot;&gt;Page a&lt;/a&gt; &lt;button onclick={openWin()}&gt;openWindow&lt;/button&gt; &lt;script&gt; function openWin(){ const ref=window.open(&quot;b.html&quot;,&quot;Page2&quot;); ref.focus(); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; b.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Page2&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;a.html&quot; target=&quot;Page1&quot;&gt;Page b&lt;/a&gt; &lt;button onclick={openWin()}&gt;openWindow&lt;/button&gt; &lt;script&gt; function openWin(){ const ref=window.open(&quot;a.html&quot;,&quot;Page1&quot;); ref.focus(); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ","link":"https://JoelynZhou.github.io/post/liu-lan-qi-xin-kai-tab-yu-dao-de-wen-ti-ji-lu/"},{"title":"面试题51. 数组中的逆序对","content":"题目 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 0 &lt;= 数组长度 &lt;= 50000 示例 输入: [7,5,6,4] 输出: 5 分析 逆序对反映了一个数组的有序程度。 思路 1：暴力解法 遍历求出每个数字后面比他小的数字个数和 时间复杂度 O(n^2) 空间复杂度 O(1) 结果：计算结果超时 思路 2：归并排序 ","link":"https://JoelynZhou.github.io/post/mian-shi-ti-51-shu-zu-zhong-de-ni-xu-dui/"},{"title":"199. 二叉树的右视图","content":"题目 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例 输入: [1,2,3,null,5,null,4] 输出: [1, 3, 4] 解释: 1 &lt;--- / \\ 2 3 &lt;--- \\ \\ 5 4 &lt;--- 分析 本题可以看成是求二叉树每层的最后一个数据组成的数组。 题解 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number[]} */ var rightSideView = function(root) { if (!root) return []; let arr = []; // 暂存每层数据 let res = []; // 存储每层最后一个数据 arr.push(root); while (arr.length &gt; 0) { res.push(arr[arr.length - 1].val); //将每层最后一个数据存入数组 let len = arr.length; while (len &gt; 0) { let now = arr.shift(); if (now.left != null) arr.push(now.left); if (now.right != null) arr.push(now.right); len--; } } return res; }; ","link":"https://JoelynZhou.github.io/post/199-er-cha-shu-de-you-shi-tu/"},{"title":"1248. 统计「优美子数组」","content":"题目 给你一个整数数组 nums 和一个整数 k。 如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。 请返回这个数组中「优美子数组」的数目。 示例 输入：nums = [1,1,2,1,1], k = 3 输出：2 解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。 输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2 输出：16 分析 本题难在考察边界条件。 题解 /** * @param {number[]} nums * @param {number} k * @return {number} */ var numberOfSubarrays = function(nums, k) { let count = 0; let arr = []; // 用于放置奇数下标 for (let i = 0; i &lt; nums.length; i++) { if (nums[i] % 2 === 1) { arr.push(i); } } if (arr.length &lt; k) { return count; } for (let i = 0; i + k - 1 &lt; arr.length; i++) { const j = i + k - 1; // 左下标 i，右下标 i+k-1 const left = i === 0 ? arr[i] + 1 : arr[i] - arr[i - 1]; const right = j === arr.length - 1 ? nums.length - arr[j] : arr[j + 1] - arr[j]; count += left * right; } return count; }; ","link":"https://JoelynZhou.github.io/post/1248-tong-ji-you-mei-zi-shu-zu/"},{"title":"200. 岛屿数量","content":"题目 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 输入: 11110 11010 11000 00000 输出: 1 输入: 11000 11000 00100 00011 输出: 3 解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。 分析 思路：DFS 跟离陆地最远的海洋问题类似。 一旦发现岛屿，计数，沉岛，查看岛屿边界； 题解 /** * @param {character[][]} grid * @return {number} */ var numIslands = function(grid) { const mark=(x,y)=&gt;{ if(x&lt;0 || y&lt;0 || x&gt;=m || y&gt;=n){ return; } if(grid[x][y]===&quot;1&quot;){ grid[x][y]=&quot;0&quot;; mark(x-1,y); mark(x+1,y); mark(x,y-1); mark(x,y+1); } } if(grid.length===0){ return 0; } const m=grid.length;const n=grid[0].length; let count=0; for(let i=0;i&lt;m;i++){ for(let j=0;j&lt;n;j++){ if(grid[i][j]===&quot;1&quot;){ count++; //发现一块新岛屿 // 标记岛屿直到边界 mark(i,j); } } } return count; }; ","link":"https://JoelynZhou.github.io/post/200-dao-yu-shu-liang/"},{"title":"466. 统计重复个数","content":"题目 由 n 个连接的字符串 s 组成字符串 S，记作 S = [s,n]。例如，[&quot;abc&quot;,3]=“abcabcabc”。 如果我们可以从 s2 中删除某些字符使其变为 s1，则称字符串 s1 可以从字符串 s2 获得。例如，根据定义，&quot;abc&quot; 可以从 “abdbec” 获得，但不能从 “acbbe” 获得。 现在给你两个非空字符串 s1 和 s2（每个最多 100 个字符长）和两个整数 0 ≤ n1 ≤ 10^6 和 1 ≤ n2 ≤ 10^6。现在考虑字符串 S1 和 S2，其中 S1=[s1,n1] 、S2=[s2,n2] 。 请你找出一个可以满足使[S2,M] 从 S1 获得的最大整数 M 。 示例 输入： s1 =&quot;acb&quot;,n1 = 4 s2 =&quot;ab&quot;,n2 = 2 返回： 2 分析 n1,n2 很大，没有办法吧 S1,S2 按照循环写出链式结果 ","link":"https://JoelynZhou.github.io/post/466-tong-ji-chong-fu-ge-shu/"},{"title":"11. 盛最多水的容器","content":"题目 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 输入：[1,8,6,2,5,4,8,3,7] 输出：49 分析 考点：双指针 跟接雨水的题很像，但是比那道题更简单，接雨水本质上是若干柱子组成的不规则图形的面积，而这里只需要考虑首尾柱子构成的矩形面积。 题解 /** * @param {number[]} height * @return {number} */ var maxArea = function (height) { let m=0;n=height.length-1; let max=0; while(m&lt;n){ max=Math.max(max,(n-m)*Math.min(height[m],height[n])); if(height[m]&gt;=height[n]){ n--; }else{ m++; } } return max; }; ","link":"https://JoelynZhou.github.io/post/11-sheng-zui-duo-shui-de-rong-qi/"},{"title":"55. 跳跃游戏","content":"题目 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 输入: [2,3,1,1,4] 输出: true 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。 输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 分析 思路 1：贪心算法 遍历每一个能调到的最远距离内的点 更新最远距离 如果遍历的点超出了最远距离，则说明当前最远距离无法到达最后，return false 否则，return true 思路 2：动态规划 从后往前，判断倒数第二个元素能否到达最后一个元素，如果可以，则将最后一个元素移出考虑范围 题解 1 /** * @param {number[]} nums * @return {boolean} */ var canJump = function(nums) { let k=0; // 能跳的最远距离 for(let i=0;i&lt;nums.length;i++){ if(i&gt;k){ return false; } k=Math.max(k,i+nums[i]); } return true; }; 题解 2 /** * @param {number[]} nums * @return {boolean} */ var canJump = function(nums) { if(nums.length===0){ return false; } let dp=new Array(nums.length).fill(false); dp[0]=true; // 第 0 个位置可达 for(let i=1;i&lt;nums.length;i++){ for(let j=0;j&lt;i;j++){ if(dp[j] &amp;&amp; nums[j]+j &gt;= i){ dp[i]=true; break; // 第 i 个位置可达，则不用再判断 dp[i]，调到下一个循环 } } } return dp[nums.length-1]; }; 参考 【跳跃游戏】别想那么多，就挨着跳吧 ","link":"https://JoelynZhou.github.io/post/55-tiao-yue-you-xi/"},{"title":"57. 插入区间","content":"题目 给出一个无重叠的 ，按照区间起始端点排序的区间列表。 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 示例 输入: intervals = [[1,3],[6,9]], newInterval = [2,5] 输出: [[1,5],[6,9]] 输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] 输出: [[1,2],[3,10],[12,16]] 解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 分析 1 用 56 题合并区间的思路解决： - 插入的区间与原区间集合合并（不考虑顺序） - 排序 并 合并区间 题解 1 /** * @param {number[][]} intervals * @param {number[]} newInterval * @return {number[][]} */ var insert = function(intervals, newInterval) { // 过滤掉区间集合中被新区间包含的点 intervals=intervals.filter(x=&gt; x[0]&lt; newInterval[0] || x[1]&gt;newInterval[1]) intervals.splice(intervals.length,0,newInterval); intervals=intervals.sort((a,b)=&gt; a[0]-b[0]); return merge(intervals); }; var merge = function(intervals) { // 区间集合长度小于 1时，不需要合并，返回自身 if(intervals.length&lt;=1){ return intervals; } // 将最小的区间放入集合开头 let res=intervals.slice(0,1); // 从第二个元素开始，遍历整个区间集合，依次与开始区间较小的那个区间（输出集合的最后一个区间）进行比较 for(let i=1;i&lt;intervals.length;i++){ // 如果待比较的两个区间有重合，则将两个区间合并（更新 输出集合的最后一个区间） // 即：较大的开始区间 小于等于 较小区间的结束区间 if(intervals[i][0]&lt;=res[res.length-1][1]){ res[res.length-1][1]=Math.max(res[res.length-1][1],intervals[i][1]); }else{ res.push(intervals[i]); // 待比较的两个区间没有交集，不做合并，直接存入输出集合末尾 } } return res; }; ","link":"https://JoelynZhou.github.io/post/57-cha-ru-qu-jian/"},{"title":"56. 合并区间","content":"题目 给出一个区间的集合，请合并所有重叠的区间。 示例 输入: [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]] 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 输入: [[1,4],[4,5]] 输出: [[1,5]] 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 分析 先排序，再依次合并 题解 /** * @param {number[][]} intervals * @return {number[][]} */ var merge = function(intervals) { // 区间集合长度小于 1时，不需要合并，返回自身 if(intervals.length&lt;=1){ return intervals; } // 对区间集合按照开始区间由小到大进行排序 intervals=intervals.sort((a,b)=&gt; a[0]-b[0]); // 将最小的区间放入集合开头 let res=intervals.slice(0,1); // 从第二个元素开始，遍历整个区间集合，依次与开始区间较小的那个区间（输出集合的最后一个区间）进行比较 for(let i=1;i&lt;intervals.length;i++){ // 如果待比较的两个区间有重合，则将两个区间合并（更新 输出集合的最后一个区间） // 即：较大的开始区间 小于等于 较小区间的结束区间 if(intervals[i][0]&lt;=res[res.length-1][1]){ res[res.length-1][1]=Math.max(res[res.length-1][1],intervals[i][1]); }else{ res.push(intervals[i]); // 待比较的两个区间没有交集，不做合并，直接存入输出集合末尾 } } return res; }; 引申 类似的问题57. 插入区间也可以用上述思路解决。 ","link":"https://JoelynZhou.github.io/post/56-he-bing-qu-jian/"},{"title":"542. 01 矩阵","content":"题目 给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。 两个相邻元素间的距离为 1 。 给定矩阵的元素个数不超过 10000。 给定矩阵中至少有一个元素是 0。 矩阵中的元素只在四个方向上相邻: 上、下、左、右。 示例 输入 0 0 0 0 1 0 1 1 1 输出 0 0 0 0 1 0 1 2 1 题解 /** * @param {number[][]} matrix * @return {number[][]} */ var updateMatrix = function(matrix) { const m = matrix.length; const n = matrix[0].length; let count = 0; //当前层级 let queue = []; //存放当前层级下的数据 let identity = new Array(m).fill(false).map(() =&gt; new Array(n).fill(false)); // 用于存放标记过的数据 for (let i = 0; i &lt; m; i++) { for (let j = 0; j &lt; n; j++) { if (matrix[i][j] === 0) { queue.push([ i, j ]); identity[i][j] = true; } } } const direction = [ [ 1, 0 ], [ -1, 0 ], [ 0, 1 ], [ 0, -1 ] ]; // 四个方向 while (queue.length &gt; 0) { count++; let temp = []; for (let i = 0; i &lt; queue.length; i++) { for (let j = 0; j &lt; direction.length; j++) { const x = queue[i][0] + direction[j][0]; const y = queue[i][1] + direction[j][1]; if (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &lt; n &amp;&amp; identity[x][y] === false) { identity[x][y] = true; temp.push([ x, y ]); matrix[x][y] = count; } } } queue = temp; //当前扩散的数组作为下一次遍历的数据源 } return matrix; }; ","link":"https://JoelynZhou.github.io/post/542-01-ju-zhen/"},{"title":"面试题 01.07. 旋转矩阵","content":"题目 给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。 不占用额外内存空间能否做到？ 示例 给定 matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], 原地旋转输入矩阵，使其变为: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] 分析 对第 i 行的元素旋转 90 度，变为第 i.length - i 列 步骤： 矩阵转置，第 i 行变为第 i 列 行翻转，第 i 列 变为第 i.length - i 列 题解 /** * @param {number[][]} matrix * @return {void} Do not return anything, modify matrix in-place instead. * 分析： * 矩阵的旋转可以通过 矩阵转置+翻转 实现 */ var rotate = function(matrix) { for(let i=0;i&lt;matrix.length;i++){ for(let j=i;j&lt;matrix.length;j++){ [matrix[i][j],matrix[j][i]]=[matrix[j][i],matrix[i][j]]; } } matrix.map(row=&gt; row.reverse()) }; ","link":"https://JoelynZhou.github.io/post/mian-shi-ti-0107-xuan-zhuan-ju-zhen/"},{"title":"8. 字符串转换整数 (atoi)","content":"题目 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下： 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0 。 提示： 本题中的空白字符只包括空格字符 ' ' 。 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 分析 规则概括： 去除开头空格 返回有符号整数 无视整数后面的字符 边界校验 其他情况返回 0 思路 1：parseInt() MDN: 如果parseInt的字符不是指定基数中的数字，则忽略该字符和所有后续字符，并返回解析到该点的整数值。parseInt将数字截断为整数值。允许使用前导空格和尾随空格。 思路 2： 正则匹配+边界校验 思路 3：有穷自动机（DFA） 题解1 /** * @param {string} str * @return {number} */ var myAtoi = function(str) { const num = parseInt(str, 10); if (isNaN(num)) { return 0; } else if (num &lt; Math.pow(-2, 31) || num &gt;= Math.pow(2, 31)) { return num &lt; Math.pow(-2, 31) ? Math.pow(-2, 31) : Math.pow(2, 31) - 1; } else { return num; } }; 题解 2 /** * @param {string} str * @return {number} */ var myAtoi = function(str) { let res = str.trim().match(/^(\\-|\\+)?\\d+/g); if (isNaN(res)) { return 0; } else if (res &lt; Math.pow(-2, 31)) { return Math.pow(-2, 31); } else if (res &gt;= Math.pow(2, 31)) { return Math.pow(2, 31) - 1; } else { return res; } }; 参考 有穷自动机DFA&amp;NFA (学习笔记) MDN-parseInt ","link":"https://JoelynZhou.github.io/post/8-zi-fu-chuan-zhuan-huan-zheng-shu-atoi/"},{"title":"121. 买卖股票的最佳时机","content":"题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。 注意：你不能在买入股票前卖出股票。 分析 假设第一天买入价最低，同时收益为 0； 如果第二天更低，则将第二天视为买入价，比较收益，更新收益最大值； 如果第二天更高，则更新收益最大值； 示例 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 题解 /** * @param {number[]} prices * @return {number} */ var maxProfit = function(prices) { let min=prices[0]; //假设第一天为最低价 let profit=0; //收益 for(let i=1;i&lt;prices.length;i++){ if(prices[i]&lt; min){ min=prices[i]; } profit=Math.max(profit,prices[i]-min); } return profit; }; ","link":"https://JoelynZhou.github.io/post/121-mai-mai-gu-piao-de-zui-jia-shi-ji/"},{"title":"289. 生命游戏","content":"题目 根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。 给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律： 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡； 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活； 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡； 如果死细胞周围正好有三个活细胞，则该位置死细胞复活； 根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。 示例 输入： [ [0,1,0], [0,0,1], [1,1,1], [0,0,0] ] 输出： [ [0,0,0], [1,0,1], [0,1,1], [0,1,0] ] 题解 /* eslint-disable indent */ /** * @param {number[][]} board * @return {void} Do not return anything, modify board in-place instead. * 细胞自动机模型 * 分析： * 根据百度百科描述，生存规律总结如下： * 1. 细胞周围有三个细胞为生，则该细胞为生 * 2. 细胞周围有两个细胞为生，则该细胞维持原状态 * 3. 其他情况则死 * * 这一题最主要的问题在于，不需要 return 新数组，而是修改源数组， * 但是每个细胞的状态是依赖于其他细胞的初始状态，如果修改源数组，会影响到后面的计算结果。 * 除了提示中提到的原地算法，最简单的会想到复制一份源数组，用于计算 */ var gameOfLife = function(board) { if (board.length === 0) { return board; } const copyBoard = JSON.parse(JSON.stringify(board)); // 二维数组的拷贝不能用 Array.slice(0) for (let i = 0; i &lt; board.length; i++) { for (let j = 0; j &lt; board[i].length; j++) { const num = nearAliveNum(copyBoard, i, j); //周围的活细胞个数 if (num === 3) { board[i][j] = 1; } else if (num !== 2) { board[i][j] = 0; } } } return board; }; // 查询单个细胞周围的活细胞个数 const nearAliveNum = (origin, x, y) =&gt; { let count = 0; const step = [ -1, 0, 1 ]; for (let m = 0; m &lt; 3; m++) { for (let n = 0; n &lt; 3; n++) { const a = x + step[m]; const b = y + step[n]; if (a &lt; 0 || a &gt;= origin.length || b &lt; 0 || b &gt;= origin[0].length) { continue; } else if (origin[a][b] === 1) { count++; } } } return count - origin[x][y]; }; ","link":"https://JoelynZhou.github.io/post/289-sheng-ming-you-xi/"},{"title":"20. 有效的括号","content":"题目 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 输入: &quot;()&quot; 输出: true 输入: &quot;([)]&quot; 输出: false 分析 题解 /** * @param {string} s * @return {boolean} */ var isValid = function(s) { let stack = []; for (let i = 0; i &lt; s.length; i++) { if (s[i] === '(' || s[i] === '{' || s[i] === '[') { stack.push(s[i]); } else if ( (s[i] === ')' &amp;&amp; stack.pop() !== '(') || (s[i] === '}' &amp;&amp; stack.pop() !== '{') || (s[i] === ']' &amp;&amp; stack.pop() !== '[') ) { return false; } } return stack.length===0; }; ","link":"https://JoelynZhou.github.io/post/20-you-xiao-de-gua-hao/"},{"title":"1111. 有效括号的嵌套深度","content":"题目 有效括号字符串 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「有效括号字符串」部分。 嵌套深度 depth 定义：即有效括号字符串嵌套的层数，depth(A) 表示有效括号字符串 A 的嵌套深度。详情参见题末「嵌套深度」部分。 给你一个「有效括号字符串」 seq，请你将其分成两个不相交的有效括号字符串，A 和 B，并使这两个字符串的深度最小。 不相交：每个 seq[i] 只能分给 A 和 B 二者中的一个，不能既属于 A 也属于 B 。 A 或 B 中的元素在原字符串中可以不连续。 A.length + B.length = seq.length max(depth(A), depth(B)) 的可能取值最小。 划分方案用一个长度为 seq.length 的答案数组 answer 表示，编码规则如下： answer[i] = 0，seq[i] 分给 A 。 answer[i] = 1，seq[i] 分给 B 。 如果存在多个满足要求的答案，只需返回其中任意 一个 即可。 1 &lt;= text.size &lt;= 10000 关于有效括号的问题可以参考 20 题，在下一节会讲到 示例 输入：seq = &quot;(()())&quot; 输出：[0,1,1,1,1,0] 输入：seq = &quot;()(())()&quot; 输出：[0,0,0,1,1,0,1,1] 分析 官方题解总结的很好，这里不做赘述，直接引用 方法一：用栈进行括号匹配 思路及算法 要求划分出使得最大嵌套深度最小的分组，我们首先得知道如何计算嵌套深度。我们可以通过栈实现括号匹配来计算： 维护一个栈 s，从左至右遍历括号字符串中的每一个字符： 如果当前字符是 (，就把 ( 压入栈中，此时这个 ( 的嵌套深度为栈的高度； 如果当前字符是 )，此时这个 ) 的嵌套深度为栈的高度，随后再从栈中弹出一个 (。 下面给出了括号序列 (()(())()) 在每一个字符处的嵌套深度： 括号序列 ( ( ) ( ( ) ) ( ) ) 下标编号 0 1 2 3 4 5 6 7 8 9 嵌套深度 1 2 2 2 3 3 2 2 2 1 题解 /** * @param {string} seq * @return {number[]} */ var maxDepthAfterSplit = function(seq) { let dep=0; let res=[]; for(let i=0;i&lt;seq.length;i++){ if(seq[i]===&quot;(&quot;){ res.push(++dep % 2); } if(seq[i]===&quot;)&quot;){ res.push(dep-- % 2); } } return res; } ","link":"https://JoelynZhou.github.io/post/1111-you-xiao-gua-hao-de-qian-tao-shen-du/"},{"title":"912. 排序数组","content":" 题解 1 /** * @param {number[]} nums * @return {number[]} */ var sortArray = function(nums) { return nums.sort((a,b)=&gt; a-b); }; 题解 2 参考 维基百科-排序算法 ","link":"https://JoelynZhou.github.io/post/912-pai-xu-shu-zu/"},{"title":"面试题62. 圆圈中最后剩下的数字","content":"题目 0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 示例 输入: n = 5, m = 3 输出: 3 输入: n = 10, m = 17 输出: 2 ","link":"https://JoelynZhou.github.io/post/mian-shi-ti-62-yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi/"},{"title":"1162. 地图分析","content":"题目 你现在手里有一份大小为 N x N 的『地图』（网格） grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。 我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。 如果我们的地图上只有陆地或者海洋，请返回 -1。 示例 输入：[[1,0,1],[0,0,0],[1,0,1]] 输出：2 解释： 海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。 分析 参考链接：参考链接点这里 花了好长时间去理解题意，距离最近的陆地区域的最远距离，究竟是最远距离还是最近距离，后来看了链接中大佬画的 GIF 瞬间明白了，这道题或许换个模型更容易理解。 我脑补的模型： 背景： 病毒在封闭人群中的传播（可能是最近瘟疫公司玩多了的缘故 orz）； 假设： 将陆地看成是感染人员，每个感染人员 每天 都会感染周围的人，然后 第二天新感染的人员又会感染周围的人，问：你以上帝视角，站在人群中什么位置，才是最晚被感染的人（人类之光格陵兰）。 思路： 第一天，算出被 0 号病人感染的人，剩下没感染的还有多少人 第二天，算出被 第一天感染的人 感染的人，剩下没感染多少人 …… 第 N 天，已经没有被感染的人了 得到 N 题解 /** * @param {number[][]} grid * @return {number} */ var maxDistance = function (grid) { let land = []; // 陆地源数组 let level = 0; // 返回层级 for (let i = 0; i &lt; grid.length; i++) { for (let j = 0; j &lt; grid[i].length; j++) { if (grid[i][j] === 1) { land.push([i, j]); } } } let ocean = grid.length * grid.length - land.length; // 海洋的格数 // 全是海洋或者陆地，返回 -1 if (land.length === 0 || ocean === 0) { return -1; } while (ocean &gt; 0) { level++; const temp = []; for (let i = 0; i &lt; land.length; i++) { const [x, y] = [land[i][0], land[i][1]]; // 判断 上下左右 相邻的点是否有海洋 for (let j = 0; j &lt; 4; j++) { // 边界条件校验 if ( x + dx[j] &lt; 0 || y + dy[j] &lt; 0 || x + dx[j] &gt; grid.length - 1 || y + dy[j] &gt; grid[0].length - 1 ) { continue; } // 如果发现是海洋，则标记 2（这里其实只要是非 0，其他数都可以，只为了跟未知海洋作区分），防止被重复计算 if (grid[x + dx[j]][y + dy[j]] === 0) { grid[x + dx[j]][y + dy[j]] = 2; temp.push([x + dx[j], y + dy[j]]); // 每发现一个新海洋，剩下的海洋格数就减少 1 ocean--; } } } land = temp; // 一轮扩散结束后，新扩散将代替源陆地存入 land，开始新的一轮扩散 } return level; }; const dx = [1, -1, 0, 0]; const dy = [0, 0, 1, -1]; ","link":"https://JoelynZhou.github.io/post/1162-di-tu-fen-xi/"},{"title":"820. 单词的压缩编码","content":"题目 给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。 例如，如果这个列表是 [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]，我们就可以将其表示为 S = &quot;time#bell#&quot; 和 indexes = [0, 2, 5]。 对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 &quot;#&quot; 结束，来恢复我们之前的单词列表。 那么成功对给定单词列表进行编码的最小字符串长度是多少呢？ 示例 输入: words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;] 输出: 10 说明: S = &quot;time#bell#&quot; ， indexes = [0, 2, 5] 。 分析 最初想法 首先匹配子串会让人想到 Trie 树，但本题题意是匹配后缀，所以会想到把单词翻转，构造前缀树条件，生成前缀树，计算每一个子节点到父节点的距离（ # 相当于根节点，所以需要算上根节点的个数 1 ）。 在此基础上的思考 既然每个节点的共享部分都需要反复计算，那么是不是可以理解为，其实过滤掉不用计算的是整个单词能匹配到其他单词的情况（包含关系，而不是半包含关系），那么只需要遍历每个单词，过滤掉当前单词的所有后缀以独立单词存在的情况，再对剩下的单词长度求和（别忘了根节点）即可。 题解 /** * @param {string[]} words * @return {number} */ var minimumLengthEncoding = function (words) { let set = new Set(words); for (let word of set) { for (let i = 1; i &lt; word.length; i++) { let temp = word.slice(i); set.has(temp) &amp;&amp; set.delete(temp); } } let res = [...set].reduce((acc,cur)=&gt;{ return acc+cur.length+1; },0) return res; }; ","link":"https://JoelynZhou.github.io/post/820-dan-ci-de-ya-suo-bian-ma/"},{"title":"914. 卡牌分组","content":"题目 给定一副牌，每张牌上都写着一个整数。 此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组： 每组都有 X 张牌。 组内所有的牌上都写着相同的整数。 仅当你可选的 X &gt;= 2 时返回 true。 示例 输入：[1,2,3,4,4,3,2,1] 输出：true 解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4] 输入：[1,1,2,2,2,2] 输出：true 解释：可行的分组是 [1,1]，[2,2]，[2,2] 分析 本质是求每张牌个数组成的数组的最大公约数是否大于2。 求最大公约数： 辗转相除法 题解 /** * @param {number[]} deck * @return {boolean} */ var hasGroupsSizeX = function(deck) { let map = new Map(); for(let n of deck){ map.set(n,map.has(n)?map.get(n)+1:1); } const arr = [...map.values()]; let res = arr[0]; return arr.every(i =&gt; (res = gcd(res, i)) &gt; 1); }; const gcd = (a, b) =&gt; (b === 0 ? a : gcd(b, a % b)); ","link":"https://JoelynZhou.github.io/post/914-qia-pai-fen-zu/"},{"title":"1. 两数之和","content":"题目 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 分析 粗暴遍历： 算法复杂度 O(n^2) Hash 查找： 哈希表的查找复杂度是 O(1)， 所以整体复杂度 O(n) 题解 /** * @param {number[]} nums * @param {number} target * @return {number[]} * 分析： * 基于 哈希表的查找复杂度是 O(1) * 通过哈希表，遍历一次，算法复杂度O(n) */ var twoSum = function(nums, target) { const hashMap=new Map(); for(let i=0;i&lt;nums.length;i++){ if(hashMap.has(target-nums[i])){ return [hashMap.get(target-nums[i]),i]; } hashMap.set(nums[i],i); } return []; }; ","link":"https://JoelynZhou.github.io/post/1-liang-shu-zhi-he/"},{"title":"999. 车的可用捕获量","content":"题目 在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。 车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。 返回车能够在一次移动中捕获到的卒的数量。 Gif 点击这里 测试用例 输入：[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]] 输出：3 解释： 在本例中，车能够捕获所有的卒。 分析 考察方向数组的问题： 暴力法： 四层 for 循环 奇思妙解： 通过创建平面坐标系来解决 题解 /** * @param {character[][]} board * @return {number} * 分析： * 考察方向数组的问题 * 暴力法： * 四层 for 循环 * 奇思妙解： * 通过创建平面坐标系来解决 */ var numRookCaptures = function(board) { let result=0; for(let i=0;i&lt;board.length;i++){ for(let j=0;j&lt;board[i].length;j++){ //找到 R 的位置 if(board[i][j]===&quot;R&quot;){ //R 为原点创建坐标系 //向四个方向查找 return rampage(board,i,j,0,1)+rampage(board,i,j,0,-1)+rampage(board,i,j,1,0)+rampage(board,i,j,-1,0); } } } }; /** * @param {board:做标数据，x,y: R 的坐标; dx,dy:步长} */ var rampage=(board,x,y,dx,dy)=&gt;{ while(x&gt;=0 &amp;&amp; x&lt;board.length &amp;&amp; y&gt;=0 &amp;&amp; y&lt;board[x].length &amp;&amp; board[x][y]!==&quot;B&quot;){ if(board[x][y]===&quot;p&quot;){ return 1; } x+=dx; y+=dy; } return 0; } ","link":"https://JoelynZhou.github.io/post/999-che-de-ke-yong-bu-huo-liang/"},{"title":"892. 三维形体的表面积","content":"题目 在 N * N 的网格上，我们放置一些 1 * 1 * 1 的立方体。 每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。 请你返回最终形体的表面积。 1 &lt;= N &lt;= 50 0 &lt;= grid[i][j] &lt;= 50 测试用例 输入：[[2]] 输出：10 输入：[[1,2],[3,4]] 输出：34 分析 计算不规则立方体堆的表面积，rid[i][j]表示第 i 行 第 j 列的方块个数 先假设每一摞的立方体互不接触： 通过遍历累加，可以计算出每一摞立方体的表面积及不接触情况下的总表面积 再考虑接触的需要减去的部分： 一旦两摞立方体接触，那么被抵消掉的表面积应该是较矮的那一摞的高度*2 关于计算顺序: 可以假设从第 0 行第 0 列开始， 每次新增一摞的时候，加上把当前摞作为独立情况下的表面积，同时减去与左侧，上侧有接触面时抵消掉的面积，直到第 i 行第 j 列结束循环体，输出结果 题解 /** * @param {number[][]} grid * @return {number} */ var surfaceArea = function(grid) { let result=0; for(let i=0;i&lt;grid.length;i++){ for(let j=0;j&lt;grid[i].length;j++){ if(grid[i][j]&gt;0){ result+=grid[i][j]*4+2; } if(i&gt;0){ result -= Math.min(grid[i-1][j],grid[i][j])*2; } if(j&gt;0){ result -= Math.min(grid[i][j-1],grid[i][j])*2; } } } return result; }; 性能 ","link":"https://JoelynZhou.github.io/post/892-san-wei-xing-ti-de-biao-mian-ji/"},{"title":"macOS 壁纸 - VSC 快捷键","content":" ","link":"https://JoelynZhou.github.io/post/macos-bi-zhi-vsc-kuai-jie-jian/"},{"title":"macOS 壁纸 - 小鹤双拼","content":" ","link":"https://JoelynZhou.github.io/post/macos-bi-zhi-xiao-he-shuang-pin/"},{"title":"Mojave 深色模式下禁用 Chrome 深色主题","content":"背景 Mojave 深色模式下，打开很多软件都是深色主题。 Chrome 为例， 如果通过引入亮色皮肤插件的方式，不能完全解决 故寻找其他解决方案。 解决方式 $ osascript -e 'id of app &quot;Google Chrome&quot;' // com.google.Chrome $ defaults write com.google.Chrome NSRequiresAquaSystemAppearance -bool yes 重启 Chrome （恢复默认） $ defaults delete com.google.Chrome NSRequiresAquaSystemAppearance 参考 https://fankcoder.com/2019/04/28/tool-2019-04-28-fix-chrome-darkmode/ ","link":"https://JoelynZhou.github.io/post/mojave-shen-se-mo-shi-xia-jin-yong-chrome-shen-se-zhu-ti/"},{"title":"javascript 中的 this 指向问题","content":"写在前面 理解 this，记住以下两点： this 永远指向一个对象 this 的指向完全取决于调用的位置 更深层次的原因 JS 中的数据类型可以分为：基本数据类型和引用类型。其中，数组、函数、对象都是引用类型，参数传递时也是引用传递（可单独讲一下）。而函数既可以当成值传递，也可以当成对象和构造函数，所以函数运行时需要确定其当前的运行环境，因此，this 只有在函数运行时才可以最终确定运行环境（this 对于运行环境的动态切换规则）。 聊一聊 this 的几个常用使用场景 事件绑定 构造函数 定时器 call（） apply（） 事件绑定 三种方式： 行内绑定 动态绑定 事件监听 定时器 var obj={ fun:function(){ this; } } setInterval(obj.fun,100); // this 指向 window setInterval(&quot;obj.fun()&quot;,100); // this 指向 obj setInterval(obj.fun,100)其实是将 fun 这个函数的地址作为参数传递给了 setInterval方法（这个时候跟 obj 对象已经半毛钱关系都没有了），那么 100 毫秒后，函数的运行就是在 window 对象下了； 而setInterval(&quot;obj.fun()&quot;,100)的第一个参数其实是一段可执行代码，当 js 开始执行这段代码时，是先找到 obj 下的 fun 函数并调用执行，所以函数的运行环境仍然在 obj 对象内，所以 this 就指向 obj 对象了。 call() &amp;&amp; apply() call() func.call(obj,arg1,arg2,...argN) // obj 是 this 要指向的对象 // arg1... 是参数列表 apply() func.apply(obj,[arg1,arg2,...argN]) // obj 是 this 要指向的对象 // [arg1...] 是参数列表，要求是数组 Call 和 Apply 作用一致，只是函数实参的传递方式不一样，二者都用来强制指定函数调用时 this 的指向。 关于 闭包的 this 指向问题，后面会单独拉一篇文章出来讲。 参考 彻底搞懂 JavaScript 中的 this 指向问题 ","link":"https://JoelynZhou.github.io/post/javascript-zhong-de-this-zhi-xiang-wen-ti/"},{"title":"XmlHttpRequest & Ajax & Fetch & Axios","content":"[注：Image by Birgit Böllinger from Pixabay] XmlHttpRequest var xhr=new XMLHttpRequest(); xhr.open(&quot;GET&quot;,url); xhr.responseType=&quot;json&quot;; xhr.onload=function(){ console.log(xhr.response); } xhr.onerror=function(){ console.log(&quot;error&quot;); } xhr.send(); 在不重新加载页面的情况下更新页面 在页面已加载后从服务器请求/接收数据 在后台向服务器发送数据 ajax $.ajax({ type:&quot;post&quot;, url:url, data:data, dataType:dataType, success:function(){}, error:function(){} }) 对原生 XHR 的封装 增加了对 JSONP 的支持 缺点： 针对 MVC 编程，不符合前端 MVVM 的浪潮 架构不清晰，如果有多个请求或者依赖关系，容易形成回调地狱 为了 ajax 引入 jQuery 不合理 axios axios({ method:&quot;post&quot;, url:url, data:data, }).then(response=&gt;{ console.log(response); }).catch(err=&gt;{ console.log(err); }) 从 node.js 创建 http 请求 也是对原生 XHR 的封装，但是是 Promise 的实现版本，符合最新 ES 规范 客户端支持防止 CSRF 提供了一些并发请求的接口 缺点： 只支持现代浏览器 fetch fetch(&quot;/users.json&quot;,{ method:&quot;post&quot;, mode:&quot;no-cors&quot;, data:{} }).then(function(response){ return response.json(); }).then(function(data){ console.log(data); }).catch(function(e){ console.log(&quot;error&quot;); }) 换成更简洁的箭头函数的写法： fetch(&quot;/users.json&quot;,{ method:&quot;post&quot;, mode:&quot;no-cors&quot;, data:{} }).then(response=&gt;{ return response.json(); }).then(data=&gt;{ console.log(data); }).catch(e=&gt;{ console.log(&quot;error&quot;); }) 换成 es7 async/await 的写法： try{ let response=await fetch(url); let data=await response.json(); console.log(data); }catch(e){ console.log(&quot;error&quot;,e); } Promise, generator/yield,await/async 都是现在和未来JS解决异步的标准做法，可以完美搭配使用。 总结，Fetch 优点： 语法简洁 基于标准 Promise 实现，支持 async/await 因为旧版浏览器不支持 Promise，所以需要使用 polly-fill es6-promise 同构方便 对跨域的处理 在配置中添加mode:&quot;no-cors&quot;即可 用 Fetch 遇到的坑： Fetch 请求默认不带 cookie ，需要设置 fetch(url,{credentials:&quot;include&quot;}) 服务器返回 400，500 并不会 reject，只有网络错误导致请求不能完成才会被 reject 不能中断，没有 abort, terminate, onTImeout, cancel 方法 不同于 XHR ，不能监测请求进度（但这样会比较简单） 我看了我们目前几个项目，都是基于 fetch 实现的，所以看了一下对上述坑的解决方案： import { message, Modal } from &quot;antd&quot;; import { getLocal } from &quot;common/LocaleProvider&quot;; import omitEmpty from &quot;omit-empty&quot;; //import { removeUserInfo } from &quot;utils/user&quot;; import { getSearchParamValue } from &quot;./url&quot;; function getApiDomain() { const apiip = getSearchParamValue(&quot;apiip&quot;); return apiip || window.location.host; } function checkStatus(response: Response): Response { if (!response.ok) { const error = new Error(response.statusText); switch (response.status) { case 401: window.location.pathname = &quot;/login.html&quot;; break; case 500: message.warn(&quot;server error&quot;); break; default: return response; } throw error; } return response; } export function getApiUrl(method: string) { method = method.replace(/\\./g, &quot;/&quot;); return `//${getApiDomain()}/api/${method}`; } export function doFetch( url: string, params: any, fetchMethod?: &quot;POST&quot; | &quot;GET&quot;, headers?: HeadersInit ) { const method = fetchMethod ? fetchMethod : &quot;post&quot;; params = omitEmpty(params); return fetch(url, { method, credentials: &quot;include&quot;, headers, body: JSON.stringify(params) }).then(checkStatus); } const XLocale = new Headers({ &quot;x-locale&quot;: getLocal() }); export function webapi&lt;T&gt;(method: string, params: any, apiURL?: string): Promise&lt;T&gt; { let url = apiURL ? apiURL : getApiUrl(method); // return doFetch(url, params) return doFetch(url, params, &quot;POST&quot;, XLocale) .then( response =&gt; response.json().then(json =&gt; ({ data: json, status: response.status })) as Promise&lt;{ data: any; status: number; }&gt; ) .then&lt;T&gt;(response =&gt; { if (response.status === 200 &amp;&amp; response.data.result.code !== 0) { if (response.data.result.code === 1000) { removeUserInfo(); parent.location.href = &quot;./login.html&quot;; } let msg = response.data.result.message; if (response.data.result.code === 500) { msg = msg ? msg : &quot;server error&quot;; } console.error(msg); console.log(msg); return Promise.reject({ status: 5001, // 专门为后端设置的专门接口信息错误 message: msg }); } if (response.status !== 200) { return Promise.reject({ status: response.status, message: &quot;后端接口信息：&quot; + response.data.message }); } return response.data; }) .catch(err =&gt; { const msg = err.message || &quot;&quot;; return Promise.reject({ status: 5002, message: msg.match(/Failed to fetch/gi) ? `网络不稳定，请稍后重试` : msg // `接口：${method}挂了或者没有开启CORS跨域功能，请稍等！` }); }); } 参考 https://segmentfault.com/a/1190000012836882 ","link":"https://JoelynZhou.github.io/post/xmlhttprequest-and-ajax-and-fetch-and-axios/"},{"title":"逻辑推理题-猜名次","content":"[注：Image by Dave Francis from Pixabay] 题目 有 A, B, C, D 和 E 共5个运动员，在一次比赛中，已知E肯定不是第二名或第三名，他们相互进行推测： A 说，E 一定是第一名； B 说，我是第二名； C 说，A 是最后一名； D 说，C 不是第一名； E 说，D 是第一名； 结果只有实际排名第一和第二名的运动员猜对了，其他人都猜错了。 请编写一个程序，求出这5个运动员的名次。 这个问题的常规思路其实很简单，把所有情况排列组合，有顺序，一共 种情况，再遍历校验条件是否符合。所以，难点在于，怎么用编程实现这个排列组合。 解法一：投机取巧+粗暴遍历 /** * 排列组合问题可以用二叉树来简单描述 * 思路：创建二叉树，遍历二叉树，条件校验 */ const origin = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;]; let output = []; for (let i = 12345; i &lt;= 54321; i++) { // TODO // 可以优化成寻找下一个比 12345 大的排列组合 const temp = [Math.floor(i / 10000), Math.floor(i / 1000 % 10), Math.floor(i / 100 % 10), Math.floor(i / 10 % 10), i % 10]; if (isValid(temp)) { // 校验 check(temp); } else { continue; } } console.log(output); function check(members) { if (members[1] === 5 || members[2] === 5) { return; } const list = [members[0] === 5, members[1] === 2, members[4] === 1, members[0] !== 3, members[0] === 4]; if (list[members[0] - 1] &amp;&amp; list[members[1] - 1] &amp;&amp; !list[members[2] - 1] &amp;&amp; !list[members[3] - 1] &amp;&amp; !list[members[4] - 1]) { const res = []; members.forEach(x =&gt; { res.push(origin[x - 1]); }) output.push(res); } } function isValid(arr) { let hash = {}; for (let i in arr) { if (hash[arr[i]] || arr[i] &gt; 5 || arr[i] === 0) { return false; } hash[arr[i]] = true; } return true; } 解法二：根据推论去反校验 假设都对，推互斥 function genPermutations(arr) { const result = []; function innerArr(temArr) { for (let i = 0, len = arr.length; i &lt; len; i++) { if (temArr.length == len - 1) { if (temArr.indexOf(arr[i]) &lt; 0) { result.push(temArr.concat(arr[i])); } continue; } if (temArr.indexOf(arr[i]) &lt; 0) { innerArr(temArr.concat(arr[i])); } } } innerArr([]); return result; } var permutations = genPermutations([1, 2, 3, 4, 5]) function answer(arr, fun) { // 已知E肯定不是第二名或第三名 arr = arr.filter(n =&gt; n[4] !== 2 &amp;&amp; n[4] !== 3); const result = arr.filter(fun) if (result.length === 1) { console.log(&quot;正确答案为&quot;, result); } else { console.log(&quot;错误猜想&quot;); } } // 第一种组合 // A说，E一定是第一名；=&gt; E = 1，A = 2 \bD = 1, answer(permutations, n =&gt; n[4] == 1 &amp;&amp; n[0] == 2 &amp;&amp; n[3] == 1) // 第二种组合 // E说，D是第一名; =&gt; E = 2, D = 1, answer(permutations, n =&gt; n[4] == 2 &amp;&amp; n[3] == 1) // 第三种组合 // B说，我是第二名、C说，A是最后一名；=&gt; B = 2 C=1 A==5 E!=1 D != 1 // =&gt; B = 2 C=1 A==5 answer(permutations, n =&gt; n[1] == 2 &amp;&amp; n[2] == 1 &amp;&amp; n[0] == 5) // 第四种组合 // D说，C不是第一名 // E说，D是第一名； // D ==2 =&gt; C!=1 B != 2 E!=1 A !=5 answer(permutations, n =&gt; n[3] == 2 &amp;&amp; n[2] != 1 &amp;&amp; n[1] != 2 &amp;&amp; n[4] != 1 &amp;&amp; n[0] != 5); 不用程序直接推导 本来一个很简单的题，被编程搞得这么麻烦，就想知道如果自己算就要多久，果然不超过五分钟，就有了下面的结果： ┓( ´∀` )┏ ","link":"https://JoelynZhou.github.io/post/luo-ji-tui-li-ti-cai-ming-ci/"},{"title":"2020 年度计（da）划（lian）表","content":" 关键词：专注 说在前面 问：执行这个计划会收获什么？ 答：升值加薪，更开阔的知识面，更好的身体素质，更多给自己的正向反馈（重要）。 个人健康 年计划： keep 6240 分钟（120min * 52week） 找一份有机会去全球各地的工作（五年计划） 心理健康 哈佛《幸福课》、《零极限》、《象与骑象人》、《flow》、《接纳不完美的自己》、《吸引力法则》 学习如何冥想 身体健康 报一期瑜伽课 keep 打卡 坚持带便当 每个月主动熬夜（12点）次数不超过 8 次 娱乐休闲 参加 3 个走出自闭的活动 发现 5 个上海好玩的地方 家庭生活 每周大扫除（断舍离）一次 个人成长 输入 每周一本书（包括不限于 电子书、实体书、听书） 每周一部（2 - 4 hour）电影（包括不限于电影、纪录片、公开课 ） 每天 30 min 优质公众号 每天 30 min 英语学习 每周 2-4 hour 理财学习 输出 个人博客 github 知乎 每周一次摄影（生活片段记录） 复盘（周总结、月总结、年总结） 人际交往 记住身边朋友的生日 个人习惯 生活 碗不要拖到第二天洗 尽！量！每天抹防晒！ 素质 学会倾听，好好说话 把【谢谢】改为【谢谢你】 慎独，远离舒适区 新技能 投资理财 英语 视频剪辑 尤克里里 厨艺 ","link":"https://JoelynZhou.github.io/post/2020-nian-du-ji-dahua-lianbiao/"}]}