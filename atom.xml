<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://JoelynZhou.github.io</id>
    <title>JoelynZhou</title>
    <updated>2020-04-20T13:25:46.849Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://JoelynZhou.github.io"/>
    <link rel="self" href="https://JoelynZhou.github.io/atom.xml"/>
    <subtitle>多读书 / 多看报 / 少吃零食 / 多睡觉</subtitle>
    <logo>https://JoelynZhou.github.io/images/avatar.png</logo>
    <icon>https://JoelynZhou.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, JoelynZhou</rights>
    <entry>
        <title type="html"><![CDATA[200. 岛屿数量]]></title>
        <id>https://JoelynZhou.github.io/post/200-dao-yu-shu-liang/</id>
        <link href="https://JoelynZhou.github.io/post/200-dao-yu-shu-liang/">
        </link>
        <updated>2020-04-20T13:20:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<h2 id="示例">示例</h2>
<pre><code>输入:
11110
11010
11000
00000
输出: 1

输入:
11000
11000
00100
00011
输出: 3
解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。
</code></pre>
<h2 id="分析">分析</h2>
<p>思路：DFS<br>
跟离陆地最远的海洋问题类似。<br>
一旦发现岛屿，计数，沉岛，查看岛屿边界；</p>
<h2 id="题解">题解</h2>
<pre><code class="language-javascript">/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
   const mark=(x,y)=&gt;{
        if(x&lt;0 || y&lt;0 || x&gt;=m || y&gt;=n){
            return;
        }
        if(grid[x][y]===&quot;1&quot;){
            grid[x][y]=&quot;0&quot;;
            mark(x-1,y);
            mark(x+1,y);
            mark(x,y-1);
            mark(x,y+1);
        }
    }

    if(grid.length===0){
        return 0;
    }
    const m=grid.length;const n=grid[0].length;
    let count=0;
    for(let i=0;i&lt;m;i++){
        for(let j=0;j&lt;n;j++){
            if(grid[i][j]===&quot;1&quot;){
                count++;    //发现一块新岛屿
                // 标记岛屿直到边界
                mark(i,j);
            }
        }
    }
    return count;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[466. 统计重复个数]]></title>
        <id>https://JoelynZhou.github.io/post/466-tong-ji-chong-fu-ge-shu/</id>
        <link href="https://JoelynZhou.github.io/post/466-tong-ji-chong-fu-ge-shu/">
        </link>
        <updated>2020-04-19T08:10:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>由 n 个连接的字符串 s 组成字符串 S，记作 S = [s,n]。例如，[&quot;abc&quot;,3]=“abcabcabc”。</p>
<p>如果我们可以从 s2 中删除某些字符使其变为 s1，则称字符串 s1 可以从字符串 s2 获得。例如，根据定义，&quot;abc&quot; 可以从 “abdbec” 获得，但不能从 “acbbe” 获得。</p>
<p>现在给你两个非空字符串 s1 和 s2（每个最多 100 个字符长）和两个整数 0 ≤ n1 ≤ 10^6 和 1 ≤ n2 ≤ 10^6。现在考虑字符串 S1 和 S2，其中 S1=[s1,n1] 、S2=[s2,n2] 。</p>
<p>请你找出一个可以满足使[S2,M] 从 S1 获得的最大整数 M 。</p>
<h2 id="示例">示例</h2>
<pre><code class="language-javascript">输入：
s1 =&quot;acb&quot;,n1 = 4
s2 =&quot;ab&quot;,n2 = 2

返回：
2
</code></pre>
<h2 id="分析">分析</h2>
<ul>
<li>n1,n2 很大，没有办法吧 S1,S2 按照循环写出链式结果</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[11. 盛最多水的容器]]></title>
        <id>https://JoelynZhou.github.io/post/11-sheng-zui-duo-shui-de-rong-qi/</id>
        <link href="https://JoelynZhou.github.io/post/11-sheng-zui-duo-shui-de-rong-qi/">
        </link>
        <updated>2020-04-19T07:32:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
<figure data-type="image" tabindex="1"><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="" loading="lazy"></figure>
<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<h2 id="示例">示例</h2>
<pre><code>输入：[1,8,6,2,5,4,8,3,7]
输出：49
</code></pre>
<h2 id="分析">分析</h2>
<p>考点：双指针</p>
<p>跟接雨水的题很像，但是比那道题更简单，接雨水本质上是若干柱子组成的不规则图形的面积，而这里只需要考虑首尾柱子构成的矩形面积。</p>
<h2 id="题解">题解</h2>
<pre><code class="language-javascript">/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function (height) {
    let m=0;n=height.length-1;
    let max=0;
    while(m&lt;n){
        max=Math.max(max,(n-m)*Math.min(height[m],height[n]));
        if(height[m]&gt;=height[n]){
            n--;
        }else{
            m++;
        }
    }
    return max;
};
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdz42k4vtjj30ic04eglm.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[55. 跳跃游戏]]></title>
        <id>https://JoelynZhou.github.io/post/55-tiao-yue-you-xi/</id>
        <link href="https://JoelynZhou.github.io/post/55-tiao-yue-you-xi/">
        </link>
        <updated>2020-04-17T05:06:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<h2 id="示例">示例</h2>
<pre><code>输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。

输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
</code></pre>
<h2 id="分析">分析</h2>
<p>思路 1：贪心算法</p>
<ul>
<li>遍历每一个能调到的最远距离内的点</li>
<li>更新最远距离</li>
<li>如果遍历的点超出了最远距离，则说明当前最远距离无法到达最后，return false</li>
<li>否则，return true</li>
</ul>
<p>思路 2：动态规划</p>
<ul>
<li>从后往前，判断倒数第二个元素能否到达最后一个元素，如果可以，则将最后一个元素移出考虑范围</li>
</ul>
<h2 id="题解-1">题解 1</h2>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
    let k=0; // 能跳的最远距离
    for(let i=0;i&lt;nums.length;i++){
        if(i&gt;k){
            return false;
        }
        k=Math.max(k,i+nums[i]);
    }
    return true;
};
</code></pre>
<h2 id="题解-2">题解 2</h2>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
    if(nums.length===0){
        return false;
    }
    let dp=new Array(nums.length).fill(false);
    dp[0]=true; // 第 0 个位置可达
    for(let i=1;i&lt;nums.length;i++){
        for(let j=0;j&lt;i;j++){
            if(dp[j] &amp;&amp; nums[j]+j &gt;= i){
                dp[i]=true;
                break;  // 第 i 个位置可达，则不用再判断 dp[i]，调到下一个循环
            }
        }
    }
    return dp[nums.length-1];
};
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdwom2sfoqj30i404qjrf.jpg" alt="" loading="lazy"></figure>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/jump-game/solution/55-by-ikaruga/">【跳跃游戏】别想那么多，就挨着跳吧</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[57. 插入区间]]></title>
        <id>https://JoelynZhou.github.io/post/57-cha-ru-qu-jian/</id>
        <link href="https://JoelynZhou.github.io/post/57-cha-ru-qu-jian/">
        </link>
        <updated>2020-04-16T12:51:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>给出一个无重叠的 ，按照区间起始端点排序的区间列表。</p>
<p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p>
<h2 id="示例">示例</h2>
<pre><code>输入: intervals = [[1,3],[6,9]], newInterval = [2,5]
输出: [[1,5],[6,9]]

输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
输出: [[1,2],[3,10],[12,16]]
解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。
</code></pre>
<h2 id="分析-1">分析 1</h2>
<p>用 56 题合并区间的思路解决：<br>
- 插入的区间与原区间集合合并（不考虑顺序）<br>
- 排序 并 合并区间</p>
<h2 id="题解-1">题解 1</h2>
<pre><code class="language-javascript">/**
 * @param {number[][]} intervals
 * @param {number[]} newInterval
 * @return {number[][]}
 */
var insert = function(intervals, newInterval) {
    // 过滤掉区间集合中被新区间包含的点
    intervals=intervals.filter(x=&gt; x[0]&lt; newInterval[0] || x[1]&gt;newInterval[1])
    intervals.splice(intervals.length,0,newInterval);
    intervals=intervals.sort((a,b)=&gt; a[0]-b[0]);
    return merge(intervals);
};

var merge = function(intervals) {
    // 区间集合长度小于 1时，不需要合并，返回自身
    if(intervals.length&lt;=1){
        return intervals;
    }
    // 将最小的区间放入集合开头
    let res=intervals.slice(0,1);
    // 从第二个元素开始，遍历整个区间集合，依次与开始区间较小的那个区间（输出集合的最后一个区间）进行比较
    for(let i=1;i&lt;intervals.length;i++){
        // 如果待比较的两个区间有重合，则将两个区间合并（更新 输出集合的最后一个区间）
        // 即：较大的开始区间 小于等于 较小区间的结束区间
        if(intervals[i][0]&lt;=res[res.length-1][1]){
            res[res.length-1][1]=Math.max(res[res.length-1][1],intervals[i][1]);
        }else{
            res.push(intervals[i]); // 待比较的两个区间没有交集，不做合并，直接存入输出集合末尾
        }
    }
    return res;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[56. 合并区间]]></title>
        <id>https://JoelynZhou.github.io/post/56-he-bing-qu-jian/</id>
        <link href="https://JoelynZhou.github.io/post/56-he-bing-qu-jian/">
        </link>
        <updated>2020-04-16T12:06:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>给出一个区间的集合，请合并所有重叠的区间。</p>
<h2 id="示例">示例</h2>
<pre><code>输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

输入: [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
</code></pre>
<h2 id="分析">分析</h2>
<ul>
<li>先排序，再依次合并</li>
</ul>
<h2 id="题解">题解</h2>
<pre><code class="language-javascript">/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function(intervals) {
    // 区间集合长度小于 1时，不需要合并，返回自身
    if(intervals.length&lt;=1){
        return intervals;
    }
    // 对区间集合按照开始区间由小到大进行排序
    intervals=intervals.sort((a,b)=&gt; a[0]-b[0]);
    // 将最小的区间放入集合开头
    let res=intervals.slice(0,1);
    // 从第二个元素开始，遍历整个区间集合，依次与开始区间较小的那个区间（输出集合的最后一个区间）进行比较
    for(let i=1;i&lt;intervals.length;i++){
        // 如果待比较的两个区间有重合，则将两个区间合并（更新 输出集合的最后一个区间）
        // 即：较大的开始区间 小于等于 较小区间的结束区间
        if(intervals[i][0]&lt;=res[res.length-1][1]){
            res[res.length-1][1]=Math.max(res[res.length-1][1],intervals[i][1]);
        }else{
            res.push(intervals[i]); // 待比较的两个区间没有交集，不做合并，直接存入输出集合末尾
        }
    }
    return res;
};
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdvv53k20dj30ez03ot8o.jpg" alt="" loading="lazy"></figure>
<h2 id="引申">引申</h2>
<p>类似的问题<a href="https://leetcode-cn.com/problems/insert-interval/submissions/">57. 插入区间</a>也可以用上述思路解决。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[542. 01 矩阵]]></title>
        <id>https://JoelynZhou.github.io/post/542-01-ju-zhen/</id>
        <link href="https://JoelynZhou.github.io/post/542-01-ju-zhen/">
        </link>
        <updated>2020-04-15T04:05:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</p>
<p>两个相邻元素间的距离为 1 。</p>
<ol>
<li>给定矩阵的元素个数不超过 10000。</li>
<li>给定矩阵中至少有一个元素是 0。</li>
<li>矩阵中的元素只在四个方向上相邻: 上、下、左、右。</li>
</ol>
<h2 id="示例">示例</h2>
<pre><code>输入
0 0 0
0 1 0
1 1 1
</code></pre>
<pre><code>输出
0 0 0
0 1 0
1 2 1
</code></pre>
<h2 id="题解">题解</h2>
<pre><code class="language-javascript">/**
 * @param {number[][]} matrix
 * @return {number[][]}
 */
var updateMatrix = function(matrix) {
	const m = matrix.length;
	const n = matrix[0].length;
	let count = 0; //当前层级
	let queue = []; //存放当前层级下的数据
	let identity = new Array(m).fill(false).map(() =&gt; new Array(n).fill(false)); // 用于存放标记过的数据
	for (let i = 0; i &lt; m; i++) {
		for (let j = 0; j &lt; n; j++) {
			if (matrix[i][j] === 0) {
				queue.push([ i, j ]);
				identity[i][j] = true;
			}
		}
	}
	const direction = [ [ 1, 0 ], [ -1, 0 ], [ 0, 1 ], [ 0, -1 ] ]; // 四个方向
	while (queue.length &gt; 0) {
		count++;
		let temp = [];
		for (let i = 0; i &lt; queue.length; i++) {
			for (let j = 0; j &lt; direction.length; j++) {
				const x = queue[i][0] + direction[j][0];
				const y = queue[i][1] + direction[j][1];
				if (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &lt; n &amp;&amp; identity[x][y] === false) {
					identity[x][y] = true;
					temp.push([ x, y ]);
					matrix[x][y] = count;
				}
			}
		}
		queue = temp; //当前扩散的数组作为下一次遍历的数据源
	}
	return matrix;
};
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdublyxu1jj30gl040dft.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试题 01.07. 旋转矩阵]]></title>
        <id>https://JoelynZhou.github.io/post/mian-shi-ti-0107-xuan-zhuan-ju-zhen/</id>
        <link href="https://JoelynZhou.github.io/post/mian-shi-ti-0107-xuan-zhuan-ju-zhen/">
        </link>
        <updated>2020-04-07T02:49:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p>
<p>不占用额外内存空间能否做到？</p>
<h2 id="示例">示例</h2>
<pre><code class="language-javascript">给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
</code></pre>
<h2 id="分析">分析</h2>
<ul>
<li>对第 i 行的元素旋转 90 度，变为第 i.length - i 列<br>
步骤：</li>
</ul>
<ol>
<li>矩阵转置，第 i 行变为第 i 列</li>
<li>行翻转，第 i 列 变为第 i.length - i 列</li>
</ol>
<h2 id="题解">题解</h2>
<pre><code class="language-javascript">/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 * 分析：
 * 矩阵的旋转可以通过 矩阵转置+翻转 实现
 */
var rotate = function(matrix) {
    for(let i=0;i&lt;matrix.length;i++){
        for(let j=i;j&lt;matrix.length;j++){
            [matrix[i][j],matrix[j][i]]=[matrix[j][i],matrix[i][j]];
        }
    }
    matrix.map(row=&gt; row.reverse())
};
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdl0givggkj30uy07ot8y.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[8. 字符串转换整数 (atoi)]]></title>
        <id>https://JoelynZhou.github.io/post/8-zi-fu-chuan-zhuan-huan-zheng-shu-atoi/</id>
        <link href="https://JoelynZhou.github.io/post/8-zi-fu-chuan-zhuan-huan-zheng-shu-atoi/">
        </link>
        <updated>2020-04-03T13:46:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p>
<p>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>
假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>
该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p>
<p>提示：</p>
<p>本题中的空白字符只包括空格字符 ' ' 。<br>
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<h2 id="分析">分析</h2>
<ul>
<li>规则概括：
<ul>
<li>去除开头空格</li>
<li>返回有符号整数</li>
<li>无视整数后面的字符</li>
<li>边界校验</li>
<li>其他情况返回 0</li>
</ul>
</li>
</ul>
<p>思路 1：parseInt()</p>
<blockquote>
<p>MDN:<br>
如果parseInt的字符不是指定基数中的数字，则忽略该字符和所有后续字符，并返回解析到该点的整数值。parseInt将数字<strong>截断为整数值</strong>。允许使用<strong>前导空格</strong>和尾随空格。</p>
</blockquote>
<p>思路 2： 正则匹配+边界校验</p>
<p>思路 3：有穷自动机（DFA）</p>
<h2 id="题解1">题解1</h2>
<pre><code class="language-javascript">/**
 * @param {string} str
 * @return {number}
 */
var myAtoi = function(str) {
	const num = parseInt(str, 10);
	if (isNaN(num)) {
		return 0;
	} else if (num &lt; Math.pow(-2, 31) || num &gt;= Math.pow(2, 31)) {
		return num &lt; Math.pow(-2, 31) ? Math.pow(-2, 31) : Math.pow(2, 31) - 1;
	} else {
		return num;
	}
};
</code></pre>
<h2 id="题解-2">题解 2</h2>
<pre><code class="language-javascript">/**
 * @param {string} str
 * @return {number}
 */
var myAtoi = function(str) {
	let res = str.trim().match(/^(\-|\+)?\d+/g);
	if (isNaN(res)) {
		return 0;
	} else if (res &lt; Math.pow(-2, 31)) {
		return Math.pow(-2, 31);
	} else if (res &gt;= Math.pow(2, 31)) {
		return Math.pow(2, 31) - 1;
	} else {
		return res;
	}
};
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdgwyzemojj30f603jmx3.jpg" alt="" loading="lazy"></figure>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/30009083">有穷自动机DFA&amp;NFA (学习笔记)</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt">MDN-parseInt</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[121. 买卖股票的最佳时机]]></title>
        <id>https://JoelynZhou.github.io/post/121-mai-mai-gu-piao-de-zui-jia-shi-ji/</id>
        <link href="https://JoelynZhou.github.io/post/121-mai-mai-gu-piao-de-zui-jia-shi-ji/">
        </link>
        <updated>2020-04-02T12:59:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<h2 id="分析">分析</h2>
<ul>
<li>假设第一天买入价最低，同时收益为 0；</li>
<li>如果第二天更低，则将第二天视为买入价，比较收益，更新收益最大值；</li>
<li>如果第二天更高，则更新收益最大值；</li>
</ul>
<h2 id="示例">示例</h2>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
<h2 id="题解">题解</h2>
<pre><code class="language-javascript">/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    let min=prices[0];  //假设第一天为最低价
    let profit=0; //收益
    for(let i=1;i&lt;prices.length;i++){
        if(prices[i]&lt; min){
            min=prices[i];
        }
        profit=Math.max(profit,prices[i]-min);
    }
    return profit;
};
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdfpzdve0qj30u606wt8y.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>