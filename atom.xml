<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://JoelynZhou.github.io</id>
    <title>JoelynZhou</title>
    <updated>2020-04-15T05:57:48.528Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://JoelynZhou.github.io"/>
    <link rel="self" href="https://JoelynZhou.github.io/atom.xml"/>
    <subtitle>多读书 / 多看报 / 少吃零食 / 多睡觉</subtitle>
    <logo>https://JoelynZhou.github.io/images/avatar.png</logo>
    <icon>https://JoelynZhou.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, JoelynZhou</rights>
    <entry>
        <title type="html"><![CDATA[542. 01 矩阵]]></title>
        <id>https://JoelynZhou.github.io/post/542-01-ju-zhen/</id>
        <link href="https://JoelynZhou.github.io/post/542-01-ju-zhen/">
        </link>
        <updated>2020-04-15T04:05:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</p>
<p>两个相邻元素间的距离为 1 。</p>
<ol>
<li>给定矩阵的元素个数不超过 10000。</li>
<li>给定矩阵中至少有一个元素是 0。</li>
<li>矩阵中的元素只在四个方向上相邻: 上、下、左、右。</li>
</ol>
<h2 id="示例">示例</h2>
<pre><code>输入
0 0 0
0 1 0
1 1 1
</code></pre>
<pre><code>输出
0 0 0
0 1 0
1 2 1
</code></pre>
<h2 id="题解">题解</h2>
<pre><code class="language-javascript">/**
 * @param {number[][]} matrix
 * @return {number[][]}
 */
var updateMatrix = function(matrix) {
	const m = matrix.length;
	const n = matrix[0].length;
	let count = 0; //当前层级
	let queue = []; //存放当前层级下的数据
	let identity = new Array(m).fill(false).map(() =&gt; new Array(n).fill(false)); // 用于存放标记过的数据
	for (let i = 0; i &lt; m; i++) {
		for (let j = 0; j &lt; n; j++) {
			if (matrix[i][j] === 0) {
				queue.push([ i, j ]);
				identity[i][j] = true;
			}
		}
	}
	const direction = [ [ 1, 0 ], [ -1, 0 ], [ 0, 1 ], [ 0, -1 ] ]; // 四个方向
	while (queue.length &gt; 0) {
		count++;
		let temp = [];
		for (let i = 0; i &lt; queue.length; i++) {
			for (let j = 0; j &lt; direction.length; j++) {
				const x = queue[i][0] + direction[j][0];
				const y = queue[i][1] + direction[j][1];
				if (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &lt; n &amp;&amp; identity[x][y] === false) {
					identity[x][y] = true;
					temp.push([ x, y ]);
					matrix[x][y] = count;
				}
			}
		}
		queue = temp; //当前扩散的数组作为下一次遍历的数据源
	}
	return matrix;
};
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdublyxu1jj30gl040dft.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试题 01.07. 旋转矩阵]]></title>
        <id>https://JoelynZhou.github.io/post/mian-shi-ti-0107-xuan-zhuan-ju-zhen/</id>
        <link href="https://JoelynZhou.github.io/post/mian-shi-ti-0107-xuan-zhuan-ju-zhen/">
        </link>
        <updated>2020-04-07T02:49:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p>
<p>不占用额外内存空间能否做到？</p>
<h2 id="示例">示例</h2>
<pre><code class="language-javascript">给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
</code></pre>
<h2 id="分析">分析</h2>
<ul>
<li>对第 i 行的元素旋转 90 度，变为第 i.length - i 列<br>
步骤：</li>
</ul>
<ol>
<li>矩阵转置，第 i 行变为第 i 列</li>
<li>行翻转，第 i 列 变为第 i.length - i 列</li>
</ol>
<h2 id="题解">题解</h2>
<pre><code class="language-javascript">/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 * 分析：
 * 矩阵的旋转可以通过 矩阵转置+翻转 实现
 */
var rotate = function(matrix) {
    for(let i=0;i&lt;matrix.length;i++){
        for(let j=i;j&lt;matrix.length;j++){
            [matrix[i][j],matrix[j][i]]=[matrix[j][i],matrix[i][j]];
        }
    }
    matrix.map(row=&gt; row.reverse())
};
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdl0givggkj30uy07ot8y.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[8. 字符串转换整数 (atoi)]]></title>
        <id>https://JoelynZhou.github.io/post/8-zi-fu-chuan-zhuan-huan-zheng-shu-atoi/</id>
        <link href="https://JoelynZhou.github.io/post/8-zi-fu-chuan-zhuan-huan-zheng-shu-atoi/">
        </link>
        <updated>2020-04-03T13:46:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p>
<p>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>
假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>
该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p>
<p>提示：</p>
<p>本题中的空白字符只包括空格字符 ' ' 。<br>
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<h2 id="分析">分析</h2>
<ul>
<li>规则概括：
<ul>
<li>去除开头空格</li>
<li>返回有符号整数</li>
<li>无视整数后面的字符</li>
<li>边界校验</li>
<li>其他情况返回 0</li>
</ul>
</li>
</ul>
<p>思路 1：parseInt()</p>
<blockquote>
<p>MDN:<br>
如果parseInt的字符不是指定基数中的数字，则忽略该字符和所有后续字符，并返回解析到该点的整数值。parseInt将数字<strong>截断为整数值</strong>。允许使用<strong>前导空格</strong>和尾随空格。</p>
</blockquote>
<p>思路 2： 正则匹配+边界校验</p>
<p>思路 3：有穷自动机（DFA）</p>
<h2 id="题解1">题解1</h2>
<pre><code class="language-javascript">/**
 * @param {string} str
 * @return {number}
 */
var myAtoi = function(str) {
	const num = parseInt(str, 10);
	if (isNaN(num)) {
		return 0;
	} else if (num &lt; Math.pow(-2, 31) || num &gt;= Math.pow(2, 31)) {
		return num &lt; Math.pow(-2, 31) ? Math.pow(-2, 31) : Math.pow(2, 31) - 1;
	} else {
		return num;
	}
};
</code></pre>
<h2 id="题解-2">题解 2</h2>
<pre><code class="language-javascript">/**
 * @param {string} str
 * @return {number}
 */
var myAtoi = function(str) {
	let res = str.trim().match(/^(\-|\+)?\d+/g);
	if (isNaN(res)) {
		return 0;
	} else if (res &lt; Math.pow(-2, 31)) {
		return Math.pow(-2, 31);
	} else if (res &gt;= Math.pow(2, 31)) {
		return Math.pow(2, 31) - 1;
	} else {
		return res;
	}
};
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdgwyzemojj30f603jmx3.jpg" alt="" loading="lazy"></figure>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/30009083">有穷自动机DFA&amp;NFA (学习笔记)</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt">MDN-parseInt</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[121. 买卖股票的最佳时机]]></title>
        <id>https://JoelynZhou.github.io/post/121-mai-mai-gu-piao-de-zui-jia-shi-ji/</id>
        <link href="https://JoelynZhou.github.io/post/121-mai-mai-gu-piao-de-zui-jia-shi-ji/">
        </link>
        <updated>2020-04-02T12:59:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<h2 id="分析">分析</h2>
<ul>
<li>假设第一天买入价最低，同时收益为 0；</li>
<li>如果第二天更低，则将第二天视为买入价，比较收益，更新收益最大值；</li>
<li>如果第二天更高，则更新收益最大值；</li>
</ul>
<h2 id="示例">示例</h2>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
<h2 id="题解">题解</h2>
<pre><code class="language-javascript">/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    let min=prices[0];  //假设第一天为最低价
    let profit=0; //收益
    for(let i=1;i&lt;prices.length;i++){
        if(prices[i]&lt; min){
            min=prices[i];
        }
        profit=Math.max(profit,prices[i]-min);
    }
    return profit;
};
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdfpzdve0qj30u606wt8y.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[289. 生命游戏]]></title>
        <id>https://JoelynZhou.github.io/post/289-sheng-ming-you-xi/</id>
        <link href="https://JoelynZhou.github.io/post/289-sheng-ming-you-xi/">
        </link>
        <updated>2020-04-02T03:55:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p>
<p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p>
<p>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；<br>
如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；<br>
如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；<br>
如果死细胞周围正好有三个活细胞，则该位置死细胞复活；<br>
根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p>
<h2 id="示例">示例</h2>
<pre><code>输入： 
[
  [0,1,0],
  [0,0,1],
  [1,1,1],
  [0,0,0]
]
输出：
[
  [0,0,0],
  [1,0,1],
  [0,1,1],
  [0,1,0]
]
</code></pre>
<h2 id="题解">题解</h2>
<pre><code class="language-javascript">/* eslint-disable indent */
/**
 * @param {number[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 * 细胞自动机模型
 * 分析：
 * 根据百度百科描述，生存规律总结如下：
 * 1. 细胞周围有三个细胞为生，则该细胞为生
 * 2. 细胞周围有两个细胞为生，则该细胞维持原状态
 * 3. 其他情况则死
 * 
 * 这一题最主要的问题在于，不需要 return 新数组，而是修改源数组，
 * 但是每个细胞的状态是依赖于其他细胞的初始状态，如果修改源数组，会影响到后面的计算结果。
 * 除了提示中提到的原地算法，最简单的会想到复制一份源数组，用于计算
 */
var gameOfLife = function(board) {
	if (board.length === 0) {
		return board;
	}
	const copyBoard = JSON.parse(JSON.stringify(board)); // 二维数组的拷贝不能用 Array.slice(0)
	for (let i = 0; i &lt; board.length; i++) {
		for (let j = 0; j &lt; board[i].length; j++) {
			const num = nearAliveNum(copyBoard, i, j); //周围的活细胞个数
			if (num === 3) {
				board[i][j] = 1;
			} else if (num !== 2) {
				board[i][j] = 0;
			}
		}
	}
	return board;
};
// 查询单个细胞周围的活细胞个数
const nearAliveNum = (origin, x, y) =&gt; {
	let count = 0;
	const step = [ -1, 0, 1 ];
	for (let m = 0; m &lt; 3; m++) {
		for (let n = 0; n &lt; 3; n++) {
			const a = x + step[m];
			const b = y + step[n];
			if (a &lt; 0 || a &gt;= origin.length || b &lt; 0 || b &gt;= origin[0].length) {
				continue;
			} else if (origin[a][b] === 1) {
				count++;
			}
		}
	}
	return count - origin[x][y];
};
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdfa9f3o2wj30v207cq36.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20. 有效的括号]]></title>
        <id>https://JoelynZhou.github.io/post/20-you-xiao-de-gua-hao/</id>
        <link href="https://JoelynZhou.github.io/post/20-you-xiao-de-gua-hao/">
        </link>
        <updated>2020-04-01T07:00:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>
左括号必须以正确的顺序闭合。<br>
注意空字符串可被认为是有效字符串。</p>
<h2 id="示例">示例</h2>
<pre><code>输入: &quot;()&quot;
输出: true
</code></pre>
<pre><code>输入: &quot;([)]&quot;
输出: false
</code></pre>
<h2 id="分析">分析</h2>
<h2 id="题解">题解</h2>
<pre><code class="language-javascript">/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    let stack = [];
    for (let i = 0; i &lt; s.length; i++) {
        if (s[i] === '(' || s[i] === '{' || s[i] === '[') {
            stack.push(s[i]);
        } else if (
            (s[i] === ')' &amp;&amp; stack.pop() !== '(') ||
			(s[i] === '}' &amp;&amp; stack.pop() !== '{') ||
			(s[i] === ']' &amp;&amp; stack.pop() !== '[')
        ) {
            return false;
        }
    }
    return stack.length===0;
};
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gde9zldzldj30uq072jrm.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1111. 有效括号的嵌套深度]]></title>
        <id>https://JoelynZhou.github.io/post/1111-you-xiao-gua-hao-de-qian-tao-shen-du/</id>
        <link href="https://JoelynZhou.github.io/post/1111-you-xiao-gua-hao-de-qian-tao-shen-du/">
        </link>
        <updated>2020-04-01T06:00:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>有效括号字符串 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「有效括号字符串」部分。</p>
<p>嵌套深度 depth 定义：即有效括号字符串嵌套的层数，depth(A) 表示有效括号字符串 A 的嵌套深度。详情参见题末「嵌套深度」部分。</p>
<p>给你一个「有效括号字符串」 seq，请你将其分成两个不相交的有效括号字符串，A 和 B，并使这两个字符串的深度最小。</p>
<p>不相交：每个 seq[i] 只能分给 A 和 B 二者中的一个，不能既属于 A 也属于 B 。<br>
A 或 B 中的元素在原字符串中可以不连续。<br>
A.length + B.length = seq.length<br>
max(depth(A), depth(B)) 的可能取值最小。<br>
划分方案用一个长度为 seq.length 的答案数组 answer 表示，编码规则如下：</p>
<p>answer[i] = 0，seq[i] 分给 A 。<br>
answer[i] = 1，seq[i] 分给 B 。<br>
如果存在多个满足要求的答案，只需返回其中任意 一个 即可。</p>
<ul>
<li>1 &lt;= text.size &lt;= 10000</li>
</ul>
<p><strong>关于有效括号的问题可以参考 20 题，在下一节会讲到</strong></p>
<h2 id="示例">示例</h2>
<pre><code>输入：seq = &quot;(()())&quot;
输出：[0,1,1,1,1,0]
</code></pre>
<pre><code>输入：seq = &quot;()(())()&quot;
输出：[0,0,0,1,1,0,1,1]
</code></pre>
<h2 id="分析">分析</h2>
<p>官方题解总结的很好，这里不做赘述，直接引用</p>
<blockquote>
<p>方法一：用栈进行括号匹配<br>
思路及算法<br>
要求划分出使得最大嵌套深度最小的分组，我们首先得知道如何计算嵌套深度。我们可以通过栈实现括号匹配来计算：<br>
维护一个栈 s，从左至右遍历括号字符串中的每一个字符：<br>
如果当前字符是 (，就把 ( 压入栈中，此时这个 ( 的嵌套深度为栈的高度；<br>
如果当前字符是 )，此时这个 ) 的嵌套深度为栈的高度，随后再从栈中弹出一个 (。<br>
下面给出了括号序列 (()(())()) 在每一个字符处的嵌套深度：</p>
</blockquote>
<pre><code>括号序列   ( ( ) ( ( ) ) ( ) )
下标编号   0 1 2 3 4 5 6 7 8 9
嵌套深度   1 2 2 2 3 3 2 2 2 1 
</code></pre>
<h2 id="题解">题解</h2>
<pre><code class="language-javascript">/**
 * @param {string} seq
 * @return {number[]}
 */
var maxDepthAfterSplit = function(seq) {
    let dep=0;
    let res=[];
    for(let i=0;i&lt;seq.length;i++){
        if(seq[i]===&quot;(&quot;){
            res.push(++dep % 2);
        }
        if(seq[i]===&quot;)&quot;){
            res.push(dep-- % 2);
        }
    }
    return res;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gde8abnyimj30tg07sjrm.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[912. 排序数组]]></title>
        <id>https://JoelynZhou.github.io/post/912-pai-xu-shu-zu/</id>
        <link href="https://JoelynZhou.github.io/post/912-pai-xu-shu-zu/">
        </link>
        <updated>2020-03-31T15:11:17.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gde1ljl9dwj31ca0u0jvt.jpg" alt="" loading="lazy"></figure>
<h2 id="题解-1">题解 1</h2>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function(nums) {
    return nums.sort((a,b)=&gt; a-b);
};
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gddikgsevej30ey02dq2v.jpg" alt="" loading="lazy"></figure>
<h2 id="题解-2">题解 2</h2>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">维基百科-排序算法</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试题62. 圆圈中最后剩下的数字]]></title>
        <id>https://JoelynZhou.github.io/post/mian-shi-ti-62-yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi/</id>
        <link href="https://JoelynZhou.github.io/post/mian-shi-ti-62-yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi/">
        </link>
        <updated>2020-03-30T14:11:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<h2 id="示例">示例</h2>
<pre><code class="language-javascript">输入: n = 5, m = 3
输出: 3
</code></pre>
<pre><code class="language-javascript">输入: n = 10, m = 17
输出: 2
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1162. 地图分析]]></title>
        <id>https://JoelynZhou.github.io/post/1162-di-tu-fen-xi/</id>
        <link href="https://JoelynZhou.github.io/post/1162-di-tu-fen-xi/">
        </link>
        <updated>2020-03-29T11:12:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>你现在手里有一份大小为 N x N 的『地图』（网格） grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。</p>
<p>我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。</p>
<p>如果我们的地图上只有陆地或者海洋，请返回 -1。</p>
<h2 id="示例">示例</h2>
<p>输入：[[1,0,1],[0,0,0],[1,0,1]]<br>
输出：2<br>
解释：<br>
海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。<br>
<img src="https://pic.leetcode-cn.com/23e21821e14238829dd7021a620895f40a8e42127cfe372e4791d025bb655afc.jpg" alt="" loading="lazy"></p>
<h2 id="分析">分析</h2>
<p>参考链接：<a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/solution/zhen-liang-yan-sou-huan-neng-duo-yuan-kan-wan-miao/">参考链接点这里</a></p>
<p>花了好长时间去理解题意，距离最近的陆地区域的最远距离，究竟是最远距离还是最近距离，后来看了链接中大佬画的 GIF 瞬间明白了，这道题或许换个模型更容易理解。</p>
<p>我脑补的模型：</p>
<ul>
<li>背景：
<ul>
<li>病毒在封闭人群中的传播（可能是最近瘟疫公司玩多了的缘故 orz）；</li>
</ul>
</li>
<li>假设：
<ul>
<li>将陆地看成是感染人员，每个感染人员 每天 都会感染周围的人，然后 第二天新感染的人员又会感染周围的人，问：你以上帝视角，站在人群中什么位置，才是最晚被感染的人（人类之光格陵兰）。</li>
</ul>
</li>
<li>思路：
<ul>
<li>第一天，算出被 0 号病人感染的人，剩下没感染的还有多少人</li>
<li>第二天，算出被 第一天感染的人 感染的人，剩下没感染多少人</li>
<li>……</li>
<li>第 N 天，已经没有被感染的人了</li>
<li>得到 N</li>
</ul>
</li>
</ul>
<h2 id="题解">题解</h2>
<pre><code class="language-javascript">/**
 * @param {number[][]} grid
 * @return {number}
 */
var maxDistance = function (grid) {
    let land = []; // 陆地源数组
    let level = 0; // 返回层级
    for (let i = 0; i &lt; grid.length; i++) {
        for (let j = 0; j &lt; grid[i].length; j++) {
            if (grid[i][j] === 1) {
                land.push([i, j]);
            }
        }
    }
    let ocean = grid.length * grid.length - land.length; // 海洋的格数
    // 全是海洋或者陆地，返回 -1
    if (land.length === 0 || ocean === 0) {
        return -1;
    }
    while (ocean &gt; 0) {
        level++;
        const temp = [];
        for (let i = 0; i &lt; land.length; i++) {
            const [x, y] = [land[i][0], land[i][1]];
            // 判断 上下左右 相邻的点是否有海洋
            for (let j = 0; j &lt; 4; j++) {
                // 边界条件校验
                if (
                    x + dx[j] &lt; 0 ||
                    y + dy[j] &lt; 0 ||
                    x + dx[j] &gt; grid.length - 1 ||
                    y + dy[j] &gt; grid[0].length - 1
                ) {
                    continue;
                }
                // 如果发现是海洋，则标记 2（这里其实只要是非 0，其他数都可以，只为了跟未知海洋作区分），防止被重复计算
                if (grid[x + dx[j]][y + dy[j]] === 0) {
                    grid[x + dx[j]][y + dy[j]] = 2;
                    temp.push([x + dx[j], y + dy[j]]);
                    // 每发现一个新海洋，剩下的海洋格数就减少 1
                    ocean--;
                }
            }
        }
        land = temp; // 一轮扩散结束后，新扩散将代替源陆地存入 land，开始新的一轮扩散
    }
    return level;
};
const dx = [1, -1, 0, 0];
const dy = [0, 0, 1, -1];
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdb0fcx1xwj30g202ya9z.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>