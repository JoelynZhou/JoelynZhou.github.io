<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://JoelynZhou.github.io</id>
    <title>JoelynZhou</title>
    <updated>2020-03-28T16:02:14.836Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://JoelynZhou.github.io"/>
    <link rel="self" href="https://JoelynZhou.github.io/atom.xml"/>
    <subtitle>多读书 / 多看报 / 少吃零食 / 多睡觉</subtitle>
    <logo>https://JoelynZhou.github.io/images/avatar.png</logo>
    <icon>https://JoelynZhou.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, JoelynZhou</rights>
    <entry>
        <title type="html"><![CDATA[820. 单词的压缩编码]]></title>
        <id>https://JoelynZhou.github.io/post/820-dan-ci-de-ya-suo-bian-ma/</id>
        <link href="https://JoelynZhou.github.io/post/820-dan-ci-de-ya-suo-bian-ma/">
        </link>
        <updated>2020-03-28T15:34:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。</p>
<p>例如，如果这个列表是 [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]，我们就可以将其表示为 S = &quot;time#bell#&quot; 和 indexes = [0, 2, 5]。</p>
<p>对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 &quot;#&quot; 结束，来恢复我们之前的单词列表。</p>
<p>那么成功对给定单词列表进行编码的最小字符串长度是多少呢？</p>
<h2 id="示例">示例</h2>
<p>输入: words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]<br>
输出: 10<br>
说明: S = &quot;time#bell#&quot; ， indexes = [0, 2, 5] 。</p>
<h2 id="分析">分析</h2>
<ol>
<li>最初想法<br>
首先匹配子串会让人想到 Trie 树，但本题题意是匹配后缀，所以会想到把单词翻转，构造前缀树条件，生成前缀树，计算每一个子节点到父节点的距离（ # 相当于根节点，所以需要算上根节点的个数 1 ）。</li>
<li>在此基础上的思考<br>
既然每个节点的共享部分都需要反复计算，那么是不是可以理解为，其实过滤掉不用计算的是<strong>整个单词能匹配到其他单词</strong>的情况（包含关系，而不是半包含关系），那么只需要遍历每个单词，过滤掉当前单词的所有后缀以独立单词存在的情况，再对剩下的单词长度求和（别忘了根节点）即可。</li>
</ol>
<h2 id="题解">题解</h2>
<pre><code class="language-javascript">/**
 * @param {string[]} words
 * @return {number}
 */
var minimumLengthEncoding = function (words) {
    let set = new Set(words);
    for (let word of set) {
        for (let i = 1; i &lt; word.length; i++) {
            let temp = word.slice(i);
            set.has(temp) &amp;&amp; set.delete(temp);
        }
    }
    let res = [...set].reduce((acc,cur)=&gt;{
        return acc+cur.length+1;
    },0)
    return res;
};
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gda2e0qzo9j30i60370sp.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[914. 卡牌分组]]></title>
        <id>https://JoelynZhou.github.io/post/914-qia-pai-fen-zu/</id>
        <link href="https://JoelynZhou.github.io/post/914-qia-pai-fen-zu/">
        </link>
        <updated>2020-03-27T14:58:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>给定一副牌，每张牌上都写着一个整数。</p>
<p>此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：</p>
<p>每组都有 X 张牌。<br>
组内所有的牌上都写着相同的整数。<br>
仅当你可选的 X &gt;= 2 时返回 true。</p>
<h2 id="示例">示例</h2>
<pre><code>输入：[1,2,3,4,4,3,2,1]
输出：true
解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]
</code></pre>
<pre><code>输入：[1,1,2,2,2,2]
输出：true
解释：可行的分组是 [1,1]，[2,2]，[2,2]
</code></pre>
<h2 id="分析">分析</h2>
<p>本质是求每张牌个数组成的数组的最大公约数是否大于2。<br>
求最大公约数：</p>
<ol>
<li>辗转相除法</li>
</ol>
<h2 id="题解">题解</h2>
<pre><code class="language-javascript">/**
 * @param {number[]} deck
 * @return {boolean}
 */
var hasGroupsSizeX = function(deck) {
    let map = new Map();
    for(let n of deck){
        map.set(n,map.has(n)?map.get(n)+1:1);
    }
    const arr = [...map.values()];
    let res = arr[0];
    return arr.every(i =&gt; (res = gcd(res, i)) &gt; 1);
};
const gcd = (a, b) =&gt; (b === 0 ? a : gcd(b, a % b));
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd8vq9ma1sj30oo05imxa.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1. 两数之和]]></title>
        <id>https://JoelynZhou.github.io/post/1-liang-shu-zhi-he/</id>
        <link href="https://JoelynZhou.github.io/post/1-liang-shu-zhi-he/">
        </link>
        <updated>2020-03-26T14:02:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<h2 id="示例">示例</h2>
<pre><code>给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
</code></pre>
<h2 id="分析">分析</h2>
<ol>
<li>粗暴遍历：<br>
算法复杂度 O(n^2)</li>
<li>Hash 查找：<br>
哈希表的查找复杂度是 O(1)，<br>
所以整体复杂度 O(n)</li>
</ol>
<h2 id="题解">题解</h2>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 * 分析：
 * 基于 哈希表的查找复杂度是 O(1)
 * 通过哈希表，遍历一次，算法复杂度O(n)
 */
var twoSum = function(nums, target) {
    const hashMap=new Map();
    for(let i=0;i&lt;nums.length;i++){
        if(hashMap.has(target-nums[i])){
            return [hashMap.get(target-nums[i]),i];
        }
        hashMap.set(nums[i],i);
    }
    return [];
};
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd7ohikwrnj30pu04474c.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[999. 车的可用捕获量]]></title>
        <id>https://JoelynZhou.github.io/post/999-che-de-ke-yong-bu-huo-liang/</id>
        <link href="https://JoelynZhou.github.io/post/999-che-de-ke-yong-bu-huo-liang/">
        </link>
        <updated>2020-03-26T07:26:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。</p>
<p>车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。</p>
<p>返回车能够在一次移动中捕获到的卒的数量。</p>
<p><a href="https://assets.leetcode-cn.com/solution-static/999_fig1.gif">Gif 点击这里</a></p>
<h2 id="测试用例">测试用例</h2>
<pre><code>输入：[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]
输出：3
解释：
在本例中，车能够捕获所有的卒。
</code></pre>
<h2 id="分析">分析</h2>
<p>考察方向数组的问题：</p>
<ol>
<li>暴力法：<br>
四层 for 循环</li>
<li>奇思妙解：<br>
通过创建平面坐标系来解决</li>
</ol>
<h2 id="题解">题解</h2>
<pre><code class="language-javascript">/**
 * @param {character[][]} board
 * @return {number}
 * 分析：
 * 考察方向数组的问题
 * 暴力法：
 * 四层 for 循环
 * 奇思妙解：
 * 通过创建平面坐标系来解决
 */
var numRookCaptures = function(board) {
    let result=0;
    for(let i=0;i&lt;board.length;i++){
        for(let j=0;j&lt;board[i].length;j++){
            //找到 R 的位置
            if(board[i][j]===&quot;R&quot;){
                //R 为原点创建坐标系
                //向四个方向查找
                return rampage(board,i,j,0,1)+rampage(board,i,j,0,-1)+rampage(board,i,j,1,0)+rampage(board,i,j,-1,0);
            }
        }
    }
};

/**
 * @param {board:做标数据，x,y: R 的坐标; dx,dy:步长}
 */
var rampage=(board,x,y,dx,dy)=&gt;{
    while(x&gt;=0 &amp;&amp; x&lt;board.length &amp;&amp; y&gt;=0 &amp;&amp; y&lt;board[x].length &amp;&amp; board[x][y]!==&quot;B&quot;){
        if(board[x][y]===&quot;p&quot;){
            return 1;
        }
        x+=dx;
        y+=dy;
    }
    return 0;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd7d8br0n5j30oa0403yk.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[892. 三维形体的表面积]]></title>
        <id>https://JoelynZhou.github.io/post/892-san-wei-xing-ti-de-biao-mian-ji/</id>
        <link href="https://JoelynZhou.github.io/post/892-san-wei-xing-ti-de-biao-mian-ji/">
        </link>
        <updated>2020-03-26T03:44:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。<br>
每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。<br>
请你返回最终形体的表面积。</p>
<ul>
<li>1 &lt;= N &lt;= 50</li>
<li>0 &lt;= grid[i][j] &lt;= 50</li>
</ul>
<h2 id="测试用例">测试用例</h2>
<pre><code class="language-javascript">输入：[[2]]
输出：10
</code></pre>
<pre><code class="language-javascript">输入：[[1,2],[3,4]]
输出：34
</code></pre>
<h2 id="分析">分析</h2>
<p>计算不规则立方体堆的表面积，rid[i][j]表示第 i 行 第 j 列的方块个数</p>
<ol>
<li>先假设每一摞的立方体互不接触：<br>
通过遍历累加，可以计算出每一摞立方体的表面积及不接触情况下的总表面积</li>
<li>再考虑接触的需要减去的部分：<br>
一旦两摞立方体接触，那么被抵消掉的表面积应该是较矮的那一摞的高度*2</li>
<li>关于计算顺序:<br>
可以假设从第 0 行第 0 列开始，<br>
每次新增一摞的时候，加上把当前摞作为独立情况下的表面积，同时减去与左侧，上侧有接触面时抵消掉的面积，直到第 i 行第 j 列结束循环体，输出结果</li>
</ol>
<h3 id="题解">题解</h3>
<pre><code class="language-javascript">/**
 * @param {number[][]} grid
 * @return {number}
 */
var surfaceArea = function(grid) {
    let result=0;
    for(let i=0;i&lt;grid.length;i++){
        for(let j=0;j&lt;grid[i].length;j++){
            if(grid[i][j]&gt;0){
                result+=grid[i][j]*4+2;
            }
            if(i&gt;0){
                result -= Math.min(grid[i-1][j],grid[i][j])*2;
            }
            if(j&gt;0){
                result -= Math.min(grid[i][j-1],grid[i][j])*2;
            }
        }
    }
    return result;
};
</code></pre>
<h3 id="性能">性能</h3>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd7a7rj549j30p003q3yk.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[macOS 壁纸 - VSC 快捷键]]></title>
        <id>https://JoelynZhou.github.io/post/macos-bi-zhi-vsc-kuai-jie-jian/</id>
        <link href="https://JoelynZhou.github.io/post/macos-bi-zhi-vsc-kuai-jie-jian/">
        </link>
        <updated>2020-01-16T09:46:00.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gayjtquzr5j31uz0u0gnn.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[macOS 壁纸 - 小鹤双拼]]></title>
        <id>https://JoelynZhou.github.io/post/macos-bi-zhi-xiao-he-shuang-pin/</id>
        <link href="https://JoelynZhou.github.io/post/macos-bi-zhi-xiao-he-shuang-pin/">
        </link>
        <updated>2020-01-16T09:43:43.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gayjkzgvvij31c00u0di9.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mojave 深色模式下禁用 Chrome 深色主题]]></title>
        <id>https://JoelynZhou.github.io/post/mojave-shen-se-mo-shi-xia-jin-yong-chrome-shen-se-zhu-ti/</id>
        <link href="https://JoelynZhou.github.io/post/mojave-shen-se-mo-shi-xia-jin-yong-chrome-shen-se-zhu-ti/">
        </link>
        <updated>2019-12-31T10:31:37.000Z</updated>
        <content type="html"><![CDATA[<h3 id="背景">背景</h3>
<p>Mojave 深色模式下，打开很多软件都是深色主题。</p>
<p>Chrome 为例，</p>
<p>如果通过引入亮色皮肤插件的方式，不能完全解决</p>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gag3jx9skyj31c00u04bh.jpg" alt="" loading="lazy"></figure>
<p>故寻找其他解决方案。</p>
<h3 id="解决方式">解决方式</h3>
<ol>
<li></li>
</ol>
<pre><code class="language-bash">$ osascript -e 'id of app &quot;Google Chrome&quot;'
// com.google.Chrome
</code></pre>
<ol start="2">
<li></li>
</ol>
<pre><code class="language-bash">$ defaults write com.google.Chrome NSRequiresAquaSystemAppearance -bool yes
</code></pre>
<ol start="3">
<li>重启 Chrome</li>
<li>（恢复默认）</li>
</ol>
<pre><code class="language-bash">$ defaults delete com.google.Chrome NSRequiresAquaSystemAppearance
</code></pre>
<h3 id="参考">参考</h3>
<ul>
<li>https://fankcoder.com/2019/04/28/tool-2019-04-28-fix-chrome-darkmode/</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[javascript 中的 this 指向问题]]></title>
        <id>https://JoelynZhou.github.io/post/javascript-zhong-de-this-zhi-xiang-wen-ti/</id>
        <link href="https://JoelynZhou.github.io/post/javascript-zhong-de-this-zhi-xiang-wen-ti/">
        </link>
        <updated>2019-11-20T02:31:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="写在前面">写在前面</h2>
<p>理解 this，记住以下两点：</p>
<ul>
<li>this 永远指向一个对象</li>
<li>this 的指向完全取决于调用的位置</li>
</ul>
<h2 id="更深层次的原因">更深层次的原因</h2>
<p>JS 中的数据类型可以分为：基本数据类型和引用类型。其中，数组、函数、对象都是引用类型，参数传递时也是引用传递（可单独讲一下）。而函数既可以当成值传递，也可以当成对象和构造函数，所以函数运行时需要确定其当前的运行环境，因此，this 只有在函数运行时才可以最终确定运行环境（this 对于运行环境的动态切换规则）。</p>
<h2 id="聊一聊-this-的几个常用使用场景">聊一聊 this 的几个常用使用场景</h2>
<ul>
<li>事件绑定</li>
<li>构造函数</li>
<li>定时器</li>
<li>call（）</li>
<li>apply（）</li>
</ul>
<h3 id="事件绑定">事件绑定</h3>
<p>三种方式：</p>
<ul>
<li>行内绑定</li>
<li>动态绑定</li>
<li>事件监听</li>
</ul>
<h3 id="定时器">定时器</h3>
<pre><code class="language-javascript">var obj={
    fun:function(){
        this;
    }
}
setInterval(obj.fun,100);	// this 指向 window
setInterval(&quot;obj.fun()&quot;,100);	// this 指向 obj
</code></pre>
<p><code>setInterval(obj.fun,100)</code>其实是将 fun 这个函数的地址作为参数传递给了 <code>setInterval</code>方法（这个时候跟 obj 对象已经半毛钱关系都没有了），那么 100 毫秒后，函数的运行就是在 window 对象下了；</p>
<p>而<code>setInterval(&quot;obj.fun()&quot;,100)</code>的第一个参数其实是一段可执行代码，当 js 开始执行这段代码时，是先找到 obj 下的 fun 函数并调用执行，所以函数的运行环境仍然在 obj 对象内，所以 this 就指向 obj 对象了。</p>
<h3 id="call-apply">call() &amp;&amp; apply()</h3>
<ul>
<li>call()</li>
</ul>
<pre><code class="language-javascript">func.call(obj,arg1,arg2,...argN)
// obj 是 this 要指向的对象
// arg1... 是参数列表
</code></pre>
<ul>
<li>apply()</li>
</ul>
<pre><code class="language-javascript">func.apply(obj,[arg1,arg2,...argN])
// obj 是 this 要指向的对象
// [arg1...] 是参数列表，要求是数组
</code></pre>
<blockquote>
<p>Call 和 Apply 作用一致，只是函数实参的传递方式不一样，二者都用来强制指定函数调用时 this 的指向。</p>
</blockquote>
<p>关于 闭包的 this 指向问题，后面会单独拉一篇文章出来讲。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/42145138">彻底搞懂  JavaScript 中的 this 指向问题</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XmlHttpRequest & Ajax & Fetch & Axios]]></title>
        <id>https://JoelynZhou.github.io/post/xmlhttprequest-and-ajax-and-fetch-and-axios/</id>
        <link href="https://JoelynZhou.github.io/post/xmlhttprequest-and-ajax-and-fetch-and-axios/">
        </link>
        <updated>2019-11-18T12:49:56.000Z</updated>
        <content type="html"><![CDATA[<p>[注：Image by <a href="https://pixabay.com/users/bboellinger-4262159/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4620141">Birgit Böllinger</a> from <a href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4620141">Pixabay</a>]</p>
<h2 id="xmlhttprequest">XmlHttpRequest</h2>
<pre><code class="language-javascript">var xhr=new XMLHttpRequest();
xhr.open(&quot;GET&quot;,url);
xhr.responseType=&quot;json&quot;;

xhr.onload=function(){
    console.log(xhr.response);
}

xhr.onerror=function(){
    console.log(&quot;error&quot;);
}

xhr.send();
</code></pre>
<ul>
<li>在不重新加载页面的情况下更新页面</li>
<li>在页面已加载后从服务器请求/接收数据</li>
<li>在后台向服务器发送数据</li>
</ul>
<h2 id="ajax">ajax</h2>
<pre><code class="language-javascript">$.ajax({
    type:&quot;post&quot;,
    url:url,
    data:data,
    dataType:dataType,
    success:function(){},
    error:function(){}
})
</code></pre>
<ul>
<li><strong>对原生 XHR 的封装</strong></li>
<li>增加了对 JSONP 的支持</li>
</ul>
<p>缺点：</p>
<ul>
<li>针对 MVC 编程，不符合前端 MVVM 的浪潮</li>
<li>架构不清晰，如果有多个请求或者依赖关系，容易形成回调地狱</li>
<li>为了 ajax 引入 jQuery 不合理</li>
</ul>
<h2 id="axios">axios</h2>
<pre><code class="language-javascript">axios({
    method:&quot;post&quot;,
    url:url,
    data:data,
}).then(response=&gt;{
    console.log(response);
}).catch(err=&gt;{
    console.log(err);
})
</code></pre>
<ul>
<li>从 node.js 创建 http 请求</li>
<li>也是对原生 XHR 的封装，但是是 Promise 的实现版本，符合最新 ES 规范</li>
<li>客户端支持防止 CSRF</li>
<li><strong>提供了一些并发请求的接口</strong></li>
</ul>
<p>缺点：</p>
<ul>
<li>只支持现代浏览器</li>
</ul>
<h2 id="fetch">fetch</h2>
<pre><code class="language-javascript">fetch(&quot;/users.json&quot;,{
    method:&quot;post&quot;,
    mode:&quot;no-cors&quot;,
    data:{}
}).then(function(response){
    return response.json();
}).then(function(data){
    console.log(data);
}).catch(function(e){
    console.log(&quot;error&quot;);
})
</code></pre>
<p>换成更简洁的箭头函数的写法：</p>
<pre><code class="language-javascript">fetch(&quot;/users.json&quot;,{
    method:&quot;post&quot;,
    mode:&quot;no-cors&quot;,
    data:{}
}).then(response=&gt;{
    return response.json();
}).then(data=&gt;{
    console.log(data);
}).catch(e=&gt;{
    console.log(&quot;error&quot;);
})
</code></pre>
<p>换成 es7 async/await 的写法：</p>
<pre><code class="language-javascript">try{
    let response=await fetch(url);
    let data=await response.json();
    console.log(data);
}catch(e){
    console.log(&quot;error&quot;,e);
}
</code></pre>
<blockquote>
<p>Promise, generator/yield,await/async 都是现在和未来JS解决异步的标准做法，可以完美搭配使用。</p>
</blockquote>
<p>总结，Fetch 优点：</p>
<ul>
<li>语法简洁</li>
<li>基于标准 Promise 实现，支持 async/await
<ul>
<li>因为旧版浏览器不支持 Promise，所以需要使用 polly-fill es6-promise</li>
</ul>
</li>
<li>同构方便</li>
<li>对跨域的处理
<ul>
<li>在配置中添加<code>mode:&quot;no-cors&quot;</code>即可</li>
</ul>
</li>
</ul>
<p>用 Fetch 遇到的坑：</p>
<ul>
<li>
<p>Fetch 请求默认不带 cookie ，需要设置 <code>fetch(url,{credentials:&quot;include&quot;})</code></p>
</li>
<li>
<p>服务器返回 400，500 并不会 reject，只有网络错误导致请求不能完成才会被 reject</p>
</li>
<li>
<p>不能中断，没有 abort, terminate, onTImeout, cancel 方法</p>
</li>
<li>
<p>不同于 XHR ，不能监测请求进度（但这样会比较简单）</p>
</li>
</ul>
<p>我看了我们目前几个项目，都是基于 fetch 实现的，所以看了一下对上述坑的解决方案：</p>
<pre><code class="language-typescript">import { message, Modal } from &quot;antd&quot;;
import { getLocal } from &quot;common/LocaleProvider&quot;;
import omitEmpty from &quot;omit-empty&quot;;
//import { removeUserInfo } from &quot;utils/user&quot;;
import { getSearchParamValue } from &quot;./url&quot;;

function getApiDomain() {
	const apiip = getSearchParamValue(&quot;apiip&quot;);
	return apiip || window.location.host;
}

function checkStatus(response: Response): Response {
	if (!response.ok) {
		const error = new Error(response.statusText);
		switch (response.status) {
			case 401:
				window.location.pathname = &quot;/login.html&quot;;
				break;
			case 500:
				message.warn(&quot;server error&quot;);
				break;
			default:
				return response;
		}
		throw error;
	}
	return response;
}

export function getApiUrl(method: string) {
	method = method.replace(/\./g, &quot;/&quot;);
	return `//${getApiDomain()}/api/${method}`;
}

export function doFetch(
	url: string,
	params: any,
	fetchMethod?: &quot;POST&quot; | &quot;GET&quot;,
	headers?: HeadersInit
) {
	const method = fetchMethod ? fetchMethod : &quot;post&quot;;
	params = omitEmpty(params);
	return fetch(url, {
		method,
		credentials: &quot;include&quot;,
		headers,
		body: JSON.stringify(params)
	}).then(checkStatus);
}

const XLocale = new Headers({
	&quot;x-locale&quot;: getLocal()
});

export function webapi&lt;T&gt;(method: string, params: any, apiURL?: string): Promise&lt;T&gt; {
	let url = apiURL ? apiURL : getApiUrl(method);

	// return doFetch(url, params)
	return doFetch(url, params, &quot;POST&quot;, XLocale)
		.then(
			response =&gt;
				response.json().then(json =&gt; ({
					data: json,
					status: response.status
				})) as Promise&lt;{
					data: any;
					status: number;
				}&gt;
		)
		.then&lt;T&gt;(response =&gt; {
			if (response.status === 200 &amp;&amp; response.data.result.code !== 0) {
				if (response.data.result.code === 1000) {
					removeUserInfo();
					parent.location.href = &quot;./login.html&quot;;
				}
				let msg = response.data.result.message;
				if (response.data.result.code === 500) {
					msg = msg ? msg : &quot;server error&quot;;
				}
				console.error(msg);
				console.log(msg);
				return Promise.reject({
					status: 5001, // 专门为后端设置的专门接口信息错误
					message: msg
				});
			}
			if (response.status !== 200) {
				return Promise.reject({
					status: response.status,
					message: &quot;后端接口信息：&quot; + response.data.message
				});
			}
			return response.data;
		})
		.catch(err =&gt; {
			const msg = err.message || &quot;&quot;;
			return Promise.reject({
				status: 5002,
				message: msg.match(/Failed to fetch/gi) ? `网络不稳定，请稍后重试` : msg
				// `接口：${method}挂了或者没有开启CORS跨域功能，请稍等！`
			});
		});
}
</code></pre>
<h2 id="参考">参考</h2>
<ul>
<li>https://segmentfault.com/a/1190000012836882</li>
</ul>
]]></content>
    </entry>
</feed>